<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[集合选数最值一类问题]]></title>
      <url>/2018/03/02/%E9%9B%86%E5%90%88%E9%80%89%E6%95%B0%E6%9C%80%E5%80%BC%E4%B8%80%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>一共有两种类型，我分别介绍。</p>
<h2 id="类型一"><a href="#类型一" class="headerlink" title="类型一"></a>类型一</h2><p>先来看一道简单的题目：</p>
<blockquote>
<p><a href="http://poj.org/problem?id=2442" target="_blank" rel="external">POJ2442 Sequence</a></p>
<p>给你$m$个序列，每个序列有$n$个非负整数，你现在要在每个序列选一个数，这一共有$n^m$种方案，一种方案的值定义为所选的数的和，要你输出值最小的$n$种方案的和。<br>数据范围： $0 \lt m \le 100$, $0 \lt n \le 2000$。</p>
</blockquote>
<p>先考虑$m = 2$的情况，一共有$n ^ 2$种方案，设两个序列为$a, b$，假设我们已经把它们排好序了，即$a_i \le a_{i+1} \  (1 \le i \lt n)$, $b_i \le b_{i+1} \  (1 \le i \lt n)$。方案$f(i, j)$的值为$a_i + b_j$。$f$有以下性质：$f(i, j) \le f(i, k) \  (j \lt k)$，$f(i, j) \  (1 \lt j \le n)$如果是最后的答案，那么$f(i, j - 1)$肯定也是答案。我们只需要维护一个优先队列，初始时将$f(i, 1)$加入优先队列，从优先队列中第$k$次取出的$f(i, j)$即为第$k$小的方案，每次取出后，若$j \lt n$，把$f(i, j + 1)$加入优先队列。时间复杂度为$O(nlog_2{m})$<br>至此，我们有了$m = 2$的合并算法，当$m \gt 2$时，我们只需要将$m$个序列进行$m - 1$次合并。得到的即为答案。总的时间复杂度为$O(mnlog_{2}m)$，可以通过此题。</p>
<p>我们考虑与此题类似的一个问题，给定$n$个多重集合$c_i$，第$i$个集合的大小为$s_i$，要在每个集合中选一个数，一种方案的值定义为所选的数的和（或积），求第$k$大（或小）的方案的值。</p>
<p>对于此问题上面这个做法还不够优秀。</p>
<p>以下介绍第一种更为优秀的做法。</p>
<p>以求第$k$大为例。<br>先把集合内元素排序，再以集合的最大值与次大值的差作为关键字对集合进行排序，即对于集合$i$满足$s_{i, j} \le s_{i, j + 1}, \  s_{i, 1} - s_{i, 2} \le s_{i + 1, 1} - s_{i + 1, 2}$ (如果某个集合只有一个元素，那么这个集合只有一种选法，就可以不用考虑了)。</p>
<p>把上面$f$的维数扩展到$n$维，$f(p_1, p_2, \cdots , p_n)$代表一个方案，第$i$个集合选了第$p_i$大的数。每个集合默认选择最大的数，这种选择作为初始方案，再进行逐个集合更改所选的数。我们只需要记录当前待选择的集合的编号$i$，当前集合所选的数第$j$大的数，以及当前方案的值。之前的选择$p_1, p_2, \cdots p_{i - 1}$，完全可以丢弃，$p_{i + 1}, p_{i + 2}, \cdots p_n$默认都是选择最大的，也不用记录，所以$f$只有三维$(i, j, sum)$。<br>对$f(i, j, sum)$的后继进行定义：</p>
<blockquote>
<p>若$j \lt c_i$，$f(i, j + 1, sum - s_{i, j} + s_{i, j + 1})$是它的后继；<br>若$i \lt n$，$f(i + 1, 2, sum - s_{i + 1, 1} + s_{i + 1, 2})$是它的后继；<br>若$j = 2 \  \&amp;\&amp; \  i \lt n$，$f(i + 1, 2, sum + s_{i, 1} - s_{i, 2} - s_{i + 1, 1} + s_{i + 1, 2})$是它的后继；</p>
</blockquote>
<p>相应的，我们定义前驱。</p>
<p>我们把每种方案看成一个节点，它与它的后继之间的边为后继边，它与它的前驱之间的边为前驱边。</p>
<p>存在以下性质：</p>
<blockquote>
<p>$f(i, j, sum)$不大于它的所以后继，不小于它的所以前驱。<br>因为前面我们对集合进行了排序，<br>满足$s_{i, j} \le s_{i, j + 1}$，所以第一种和第二种后继（如果存在）存在这种性质。<br>满足$s_{i, 1} - s_{i, 2} \le s_{i + 1, 1} - s_{i + 1, 2}$，所以第三种后继（如果存在）存在这种性质。</p>
<p>$f(i, j, sum)$可以有多个后继，但只有唯一的前驱。<br>因为我们是逐位更改的，当前集合和所选的数的不同，这两种方案通过后继边所能达到的方案不会有交。</p>
<p>给一种合法的方案通过前驱边最终一定能到达初始方案。<br>即从最初方案通过后继边可以到达每种合法方案。<br>这很显然。</p>
</blockquote>
<p>那么这就是一棵树。如果一种方案成为答案，那么它的前驱肯定也是答案。那么我们可以维护一个优先队列，存当前可能成为答案的方案，第$k$个答案即为优先队列第$k$次的最大值，一种方案出队后把它的所有后继加入优先队列。</p>
<p>事实上，这种结构只要是一个$DAG$，就可以用优先队列维护了，只不过可能要去重。</p>
<p>这个算法的时间复杂度为$O(nlog_{2}n + \sum_i^n{c_ilog_{2}c_i}+ klog_{2}mk)$，其中$m$为每种方案的平均后继个数。由于$m$是常数，可以忽略，那么时间复杂度就是$O(nlog_{2}n + \sum_i^n{c_ilog_{2}c_i}+ klog_{2}k)$。这个算法是相当优秀的。</p>
<p>模板题<a href="https://loj.ac/problem/6254" target="_blank" rel="external">LibreOj #6254. 最优卡组</a></p>
<h2 id="类型二"><a href="#类型二" class="headerlink" title="类型二"></a>类型二</h2><p>假设我们始终在一个内选数，即给你一个有$n$个元素的多重集合$s$，选$m$个不同的数定义为一种方案，求第$k$大（或小）的方案的值。</p>
<p>利用上面的算法的思想，$f(p_1, p_2, \cdots , p_m) \  (1 \le p_1 \lt p_2 \lt \cdots  \lt p_m)$为一种方案。</p>
<p>定义后继：如果$f(p_1, p_2, \cdots , p_i + 1, \cdots , p_m)$合法，那么它为$f(p_1, p_2, \cdots , p_m)$的后继。<br>类似的定义前驱。</p>
<p>但是这是一个DAG，如果这样直接用优先队列做，需要去重。<br>我们再次利用逐位更改的思想，多加一维$i$，表示$p_i, p_{i + 1}, \cdots , p_m$不会更改。<br>$f(i, p_1, p_2, \cdots , p_i, \cdots , p_m)$的后继有：</p>
<blockquote>
<p>如果$f(i, p_1, p_2, \cdots , p_i + 1, \cdots , p_m)$合法，那么它为$f(i, p_1, p_2, \cdots , p_m)$的后继。<br>如果$f(j, p_1, p_2, \cdots , p_j + 1, \cdots , p_m) \  (1 \le j \lt i)$，那么它为$f(i, p_1, p_2, \cdots , p_m)$的后继。</p>
</blockquote>
<p>显然它也有上面的三个性质。<br>那么这就是一颗树了，可以直接用优先队列做，不需要去重了。</p>
<blockquote>
<p><a href="http://acm.sgu.ru/problem.php?contest=0&amp;problem=421" target="_blank" rel="external">Sgu 421. k-th Product</a></p>
<p>给出$n$个整数$a_1, a_2, \cdots , a_n$，问从中选$m$个数乘积第$k$大是多少。<br>数据范围：$1 \le n,k \le 10000$, $1 \le m \le13$, $k \le C^n_m$, $-10^6 \le a_i \le10^6$。</p>
</blockquote>
<p>假如求的是数和的第$k$大，或正整数的乘积第$k$大是多少，那么可以直接用上面的那个算法。<br>但是所选的负数的个数或影响乘积的正负，所以我们枚举$m$中选的负数的个数。如果负数个数为偶数，这类方案的乘积非负，选择求绝对值前$k$大的乘积。反之，这类方案的乘积非正，选择求绝对值前$k$小的乘积。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://poj.org/problem?id=2442" target="_blank" rel="external">POJ2442 Sequence</a><br><a href="https://buaacoding.cn/contest-ng/index.html#/188/problems" target="_blank" rel="external">第十三届北航程序设计竞赛预赛</a><br><a href="http://blog.csdn.net/skywalkert/article/details/78848170#m-最优卡组" target="_blank" rel="external">第十三届北航程序设计竞赛预赛题解</a><br><a href="https://loj.ac/problem/6254" target="_blank" rel="external">LibreOj #6254. 最优卡组</a><br><a href="http://acm.sgu.ru/problem.php?contest=0&amp;problem=421" target="_blank" rel="external">Sgu 421. k-th Product</a><br><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1425" target="_blank" rel="external">bzoj 1425: SGU 421 k-th Product</a><br><a href="https://blog.sengxian.com/solutions/bzoj-1425" target="_blank" rel="external">Sengxian’s Blog</a><br><a href="https://wenku.baidu.com/view/1283f388d0d233d4b14e6912" target="_blank" rel="external">ZJOI2010讲课</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[AtCoder Beginner Contest 077]]></title>
      <url>/2017/11/05/AtCoder-Beginner-Contest-077/</url>
      <content type="html"><![CDATA[<h2 id="A-Rotation"><a href="#A-Rotation" class="headerlink" title="A - Rotation"></a>A - Rotation</h2><p>Time limit : 2sec / Memory limit : 256MB</p>
<p>Score : 100 points</p>
<h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><blockquote>
<p>You are given a grid with $2$ rows and $3$ columns of squares. The color of the square at the i-th row and j-th column is represented by the character $C_{ij}$.<br>Write a program that prints $YES$ if this grid remains the same when rotated $180$ degrees, and prints $NO$ otherwise.</p>
</blockquote>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><blockquote>
<ul>
<li>$C_{i,j} \  (1 \le i \le 2, 1 \le j \le 3)$ is a lowercase English letter.</li>
</ul>
</blockquote>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote>
<p>Input is given from Standard Input in the following format:</p>
<blockquote>
<p>$C_{11}C_{12}C_{13}$<br>$C_{21}C_{22}C_{23}$</p>
</blockquote>
</blockquote>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote>
<p>Print $YES$ if this grid remains the same when rotated $180$ degrees; print $NO$ otherwise.</p>
</blockquote>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><blockquote>
<p>pot<br>top</p>
</blockquote>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><blockquote>
<p>YES</p>
<p>This grid remains the same when rotated $180$ degrees.</p>
</blockquote>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><blockquote>
<p>tab<br>bet</p>
</blockquote>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><blockquote>
<p>NO</p>
<p>This grid does not remain the same when rotated $180$ degrees.</p>
</blockquote>
<h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h3><blockquote>
<p>eye<br>eel</p>
</blockquote>
<h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h3><blockquote>
<p>NO</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><blockquote>
<p>给你一个$2 \times 3$的字符矩阵，问你将他选择$180°$以后是否跟原来一样。<br>满足的条件为$C_11 = C_23 \  \&amp; \&amp; \  C_12 = C_22 \  \&amp; \&amp; \  C_13 = C21$。</p>
</blockquote>
<pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

int main() {
    char c11, c12, c13, c21, c22, c23;
    cin &gt;&gt; c11 &gt;&gt; c12 &gt;&gt; c13 &gt;&gt; c21 &gt;&gt; c22 &gt;&gt; c23;
    if (c11 != c23 || c12 != c22 || c13 != c21) puts(&quot;NO&quot;);
    else puts(&quot;YES&quot;);
    return 0;
}
</code></pre>
<p><br><br></p>
<h2 id="B-Around-Square"><a href="#B-Around-Square" class="headerlink" title="B - Around Square"></a>B - Around Square</h2><p>Time limit : 2sec / Memory limit : 256MB</p>
<p>Score : 200 points</p>
<h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><blockquote>
<p>Find the largest square number not exceeding $N$. Here, a square number is an integer that can be represented as the square of an integer.</p>
</blockquote>
<h3 id="Constraints-1"><a href="#Constraints-1" class="headerlink" title="Constraints"></a>Constraints</h3><blockquote>
<ul>
<li>$1 \le N \le 10^9$</li>
<li>$N$ is an integer.</li>
</ul>
</blockquote>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><blockquote>
<p>Input is given from Standard Input in the following format:</p>
<blockquote>
<p>$N$</p>
</blockquote>
</blockquote>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><blockquote>
<p>Print the largest square number not exceeding $N$.</p>
</blockquote>
<h3 id="Sample-Input-1-1"><a href="#Sample-Input-1-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><blockquote>
<p>10</p>
</blockquote>
<h3 id="Sample-Output-1-1"><a href="#Sample-Output-1-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><blockquote>
<p>9</p>
<p>$10$ is not square, but $9 = 3 \times 3$ is. Thus, we print $9$.</p>
</blockquote>
<h3 id="Sample-Input-2-1"><a href="#Sample-Input-2-1" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><blockquote>
<p>81</p>
</blockquote>
<h3 id="Sample-Output-2-1"><a href="#Sample-Output-2-1" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><blockquote>
<p>81</p>
</blockquote>
<h3 id="Sample-Input-3-1"><a href="#Sample-Input-3-1" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h3><blockquote>
<p>271828182</p>
</blockquote>
<h3 id="Sample-Output-3-1"><a href="#Sample-Output-3-1" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h3><blockquote>
<p>271821169</p>
</blockquote>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><blockquote>
<p>问你小于等于$n$的最大的完全平方数。<br>${\lfloor \sqrt{n} \rfloor}^2$。</p>
</blockquote>
<pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    n = sqrt(n);
    printf(&quot;%d\n&quot;, n * n);
    return 0;
}
</code></pre>
<p><br><br></p>
<h2 id="C-Snuke-Festival"><a href="#C-Snuke-Festival" class="headerlink" title="C - Snuke Festival"></a>C - Snuke Festival</h2><p>Time limit : 2sec / Memory limit : 256MB</p>
<p>Score : 300 points</p>
<h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><blockquote>
<p>The season for Snuke Festival has come again this year. First of all, Ringo will perform a ritual to summon Snuke. For the ritual, he needs an altar, which consists of three parts, one in each of the three categories: upper, middle and lower.<br>He has $N$ parts for each of the three categories. The size of the i-th upper part is $A_i$, the size of the i-th middle part is $B_i$, and the size of the i-th lower part is $C_i$.<br>To build an altar, the size of the middle part must be strictly greater than that of the upper part, and the size of the lower part must be strictly greater than that of the middle part. On the other hand, any three parts that satisfy these conditions can be combined to form an altar.<br>How many different altars can Ringo build? Here, two altars are considered different when at least one of the three parts used is different.</p>
</blockquote>
<h3 id="Constraints-2"><a href="#Constraints-2" class="headerlink" title="Constraints"></a>Constraints</h3><blockquote>
<ul>
<li>$1 \le N \le 10^5$</li>
<li>$1 \le A_i \le 10^9 \  (1 \le i \le N)$</li>
<li>$1 \le B_i \le 10^9 \  (1 \le i \le N)$</li>
<li>$1 \le C_i \le 10^9 \  (1 \le i \le N)$</li>
<li>All input values are integers.</li>
</ul>
</blockquote>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><blockquote>
<p>Input is given from Standard Input in the following format:<br>$N$<br>$A_1 \cdots A_N$<br>$B_1 \cdots B_N$<br>$C_1 \cdots C_N$</p>
</blockquote>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><blockquote>
<p>Print the number of different altars that Ringo can build.</p>
</blockquote>
<h3 id="Sample-Input-1-2"><a href="#Sample-Input-1-2" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><blockquote>
<p>2<br>1 5<br>2 4<br>3 6</p>
</blockquote>
<h3 id="Sample-Output-1-2"><a href="#Sample-Output-1-2" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><blockquote>
<p>3</p>
<p>The following three altars can be built:</p>
<blockquote>
<p>Upper: 1-st part, Middle: 1-st part, Lower: 1-st part<br>Upper: 1-st part, Middle: 1-st part, Lower: 2-nd part<br>Upper: 1-st part, Middle: 2-nd part, Lower: 2-nd part</p>
</blockquote>
</blockquote>
<h3 id="Sample-Input-2-2"><a href="#Sample-Input-2-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><blockquote>
<p>3<br>1 1 1<br>2 2 2<br>3 3 3</p>
</blockquote>
<h3 id="Sample-Output-2-2"><a href="#Sample-Output-2-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><blockquote>
<p>27</p>
</blockquote>
<h3 id="Sample-Input-3-2"><a href="#Sample-Input-3-2" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h3><blockquote>
<p>6<br>3 14 159 2 6 53<br>58 9 79 323 84 6<br>2643 383 2 79 50 288</p>
</blockquote>
<h3 id="Sample-Output-3-2"><a href="#Sample-Output-3-2" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h3><blockquote>
<p>87</p>
</blockquote>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><blockquote>
<p>有$A_1 \cdots A_n, \  B_1 \cdots B_n, \  C_1 \cdots C_n$，问你$A_i \lt B_j \lt B_k \  (1 \le i,j,k \le n)$的对数。<br>对于某一类，它们之间的顺序没有关系，所以把$A,B,C$都先排序，对于每个$B_i$，$cnt[i] = \sum_{B_i \lt C_j}^{}{1}$，对于每个$A_i$，$sum[i] = \sum_{A_i \lt B_j}^{}{cnt[j]}$，答案即为$\sum_{i = 1}^n{sum[i]}$。排序后，比某个大的是一个区间，所以对于每个维护一下区间的后缀贡献和。<br>时间复杂度$O(nlog_2n)$</p>
</blockquote>
<pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int a[N], b[N], c[N], cnt[N];
LL sum[N];

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, &amp;a[i]);
    sort(a + 1, a + n + 1);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, &amp;b[i]);
    sort(b + 1, b + n + 1);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, &amp;c[i]);
    sort(c + 1, c + n + 1);
    for (int i = 1, j = 1; i &lt;= n; ++i) {
        while (j &lt; n &amp;&amp; b[i] &gt;= c[j]) ++j;
        if (b[i] &gt;= c[j]) break;
        cnt[i] = n - j + 1;
    }
    for (int i = n; i; --i)
        sum[i] = sum[i + 1] + cnt[i];
    LL res = 0;
    for (int i = 1, j = 1; i &lt;= n; ++i) {
        while (j &lt; n &amp;&amp; a[i] &gt;= b[j]) ++j;
        if (a[i] &gt;= b[j]) break;
        res += sum[j];
    }
    printf(&quot;%lld\n&quot;, res);
    return 0;
}
</code></pre>
<p><br><br></p>
<h2 id="D-Small-Multiple"><a href="#D-Small-Multiple" class="headerlink" title="D - Small Multiple"></a>D - Small Multiple</h2><p>Time limit : 2sec / Memory limit : 256MB</p>
<p>Score : 700 points</p>
<h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><blockquote>
<p>Find the smallest possible sum of the digits in the decimal notation of a positive multiple of $K$.</p>
</blockquote>
<h3 id="Constraints-3"><a href="#Constraints-3" class="headerlink" title="Constraints"></a>Constraints</h3><blockquote>
<p>$2 le K le 10^5$<br>$K$ is an integer.</p>
</blockquote>
<h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><blockquote>
<p>Input is given from Standard Input in the following format:</p>
<blockquote>
<p>K</p>
</blockquote>
</blockquote>
<h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><blockquote>
<p>Print the smallest possible sum of the digits in the decimal notation of a positive multiple of $K$.</p>
</blockquote>
<h3 id="Sample-Input-1-3"><a href="#Sample-Input-1-3" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><blockquote>
<p>6</p>
</blockquote>
<h3 id="Sample-Output-1-3"><a href="#Sample-Output-1-3" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><blockquote>
<p>3</p>
<p>$12 = 6 \times 2$ yields the smallest sum.</p>
</blockquote>
<h3 id="Sample-Input-2-3"><a href="#Sample-Input-2-3" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><blockquote>
<p>41</p>
</blockquote>
<h3 id="Sample-Output-2-3"><a href="#Sample-Output-2-3" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><blockquote>
<p>5</p>
<p>$11111 = 41 \times 271$ yields the smallest sum.</p>
</blockquote>
<h3 id="Sample-Input-3-3"><a href="#Sample-Input-3-3" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h3><blockquote>
<p>79992</p>
</blockquote>
<h3 id="Sample-Output-3-3"><a href="#Sample-Output-3-3" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h3><blockquote>
<p>36</p>
</blockquote>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><blockquote>
<p>问你$k$的正整数倍中各个数位数字之和的最小值。<br>比赛中，我没有做出这题，我试了随机化，发现效果很差。比赛后，我想出了一个数位DP，$f[i][j]$代表当前数是$i$位数，$\% k = j$的最小数字和。时间复杂度为$O(k \times 10 \times d)$。$d$为答案的位数，具体答案会多大，我也不知道，反正做个$100$位是不会超时，我觉得最小的答案应该不会超过$100$。后来发现比赛时唯一A掉的就是这么做的。<br>看了题解以后，发现这道题十分高妙。每个自然数都可以从$0$通过$+ 1$和$\times 10$这两个操作得到，前者对数位和贡献$+ 1$，后者数位和不变，且可以在模意义下做，把其转化为图论，有$k$个点，分别为$0 \cdots k - 1$，对于一个点$u$，到$(u + 1) \% k$有一条权为$1$的边，到$u *10 \% k$有一条权为$0$的边。答案即为点$1$到点$0$的最短距离$+ 1$。<br>题解还说明了某一位加到了$10$的情况。假设当前这位为$i$，我们一定可以找到$10^i ≡ 10^j (mod \  k) \  (i \lt j)$。所以我们可以把第$i$的$1$移到第$j$位，即可以构造出合法方案。<br>关于最短路，直接跑堆优化的Dijkstra时间复杂度是$O(klog_2k)$，我们考虑这张图的边权为$0$或$1$，可以使用01-BFS（堆优化Dijkstra的优先队列换成双关队列。向队列中加入新点时，通过权为$0$的边更新的点放在队首，通过权为$1$的边更新的点放在队尾）。时间复杂度为$O(k)$，这是相当优秀的复杂度了。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> AtCoder-Beginner-Contest </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[[HNSDFZ #7] 树上倍增]]></title>
      <url>/2017/11/05/HNSDFZ-7-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/</url>
      <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>现有一棵树。您需要写一个树上倍增算法，以实现如下操作：</p>
<ul>
<li><code>A x</code> 新建一个节点，将它作为<code>x</code>节点的儿子，编号为<code>当前节点总数+1</code>。</li>
<li><code>Q k p1 p2 p3....</code> 查询<code>p1,p2,p3...</code>这些节点的LCA。其中<code>k</code>表示查询节点的个数。</li>
</ul>
<p>最初树上只有一个节点，编号为<code>1</code>。<br>多个节点的LCA定义为：这些节点的公共祖先中<strong>深度最大</strong>的。</p>
</blockquote>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote>
<p>第一行，一个正整数$n$，表示操作个数。<br>接下来$n$行，每行输入一个操作，格式如<code>题目描述</code>所述。</p>
<p>保证任何输入的数都是<strong>正整数</strong>。</p>
</blockquote>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote>
<p>对于每一个<code>Q</code>操作，输出一行一个正整数，表示所询问节点的LCA。</p>
</blockquote>
<h3 id="样例数据"><a href="#样例数据" class="headerlink" title="样例数据"></a>样例数据</h3><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><blockquote>
<p>7<br>A 1<br>A 2<br>A 3<br>A 1<br>A 5<br>A 5<br>Q 2 3 6<br>Q 2 6 7<br>Q 2 4 2<br>Q 3 7 6 5</p>
</blockquote>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><blockquote>
<p>1<br>5<br>2<br>5</p>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><blockquote>
<p><code>3,6</code>的LCA是<code>1</code>。<br><code>6,7</code>的LCA是<code>5</code>。<br><code>4,2</code>的LCA是<code>2</code>。<br><code>7,6,5</code>的LCA是<code>5</code>。</p>
</blockquote>
<h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><blockquote>
<p>对于$20\%$的数据，有$n \leq 100,k=2$。<br>对于$40\%$的数据，有$n \leq 100000,k\leq 10$。<br>对于$100\%$的数据，有$n \leq 1000000,k\leq 1000$。<br>保证询问不超过$1000$次。</p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>很可惜这题被树剖暴力水过了。</p>
<h4 id="20分搞法"><a href="#20分搞法" class="headerlink" title="20分搞法"></a>20分搞法</h4><p>直接暴力LCA。</p>
<h4 id="40分搞法"><a href="#40分搞法" class="headerlink" title="40分搞法"></a>40分搞法</h4><p>老老实实写一个树上倍增或树链剖分。</p>
<h4 id="100分搞法"><a href="#100分搞法" class="headerlink" title="100分搞法"></a>100分搞法</h4><blockquote>
<p>这里有一个结论：<strong>多个节点的LCA，就是DFS序最大和最小的这两个节点的LCA</strong>。<br>我们尝试证明。DFS序是长成这样的：<br><img src="/img/post/HNSDFZ-7-树上倍增_1.png" alt="DFS序"><br>要证明原命题，只需要证明这一种特化情况：</p>
<blockquote>
<p>DFS序上，若有<code>P &lt; A &lt; B</code>，则有$\text {LCA} (P,A,B) = \text{LCA}(P,B)$。</p>
</blockquote>
<p>由上图可以看出，我们把每个节点管理的区间画出来，<strong>不会交叉</strong>，只存在包含关系。<br>由于$\text {LCA} (P,A,B)$必定在$\text {LCA} (P,B)$到根节点的路径上，所以我们<strong>只需要证明</strong>：</p>
<blockquote>
<p>DFS序上，若有<code>P &lt; A &lt; B</code>，则有$\text {LCA} (P,B)$是 $\text{LCA}(P,A)$的祖先。</p>
</blockquote>
<p>这个证明就很简单了。不妨假设$\text{LCA}(P,A)$竟敢是$\text{LCA}(P,B)$的祖先，那么就会出现如下情况：<br><img src="/img/post/HNSDFZ-7-树上倍增_2.png" alt="反证"><br>产生了交叉，所以这个假设不成立，原命题得证。<br>因此我们先把树的DFS序求出来，询问多个节点的LCA就变成了询问两个节点的LCA。<br>直接Tarjan就可以做了。</p>
</blockquote>
<p>转自<a href="https://www.zhihu.com/question/67046715/answer/248510530" target="_blank" rel="external">阮行止</a></p>
<p>下面是我的证明：</p>
<blockquote>
<p>因为最后的答案肯定是这些节点中任意两个节点的公共祖先，所以，最后的答案肯定是DFS序最大和最小的这两个节点的LCA的祖先（包括自身）。我们只需要再证明这个节点是其它所以节点的祖先即可。我们考虑DFS序，以一个节点为根的子树的所有节点的DFS序是连续的一段区间，该节点既然已经是DFS序最大和最小的这两个节点的祖先了，那么DFS序在这两个点之间的节点肯定是该节点的后代，所以命题得证。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 倍增 </tag>
            
            <tag> 最近公共祖先 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[HNSDFZ #6] 可持久化线段树]]></title>
      <url>/2017/11/05/HNSDFZ-6-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>现有一序列$A$。您需要实现一棵可持久化线段树，用于实现如下操作：</p>
<ul>
<li><code>A v p x</code>：对于版本<code>v</code>的序列，给$A_p$增加$x$.</li>
<li><code>Q v l r</code>：对于版本<code>v</code>的序列，询问$A_{[l,r]}$的区间和。</li>
<li><code>C v</code>：拷贝一份版本<code>v</code>的序列，编号为<code>当前版本总数+1</code>.</li>
</ul>
<p>注意版本号从$1$开始；版本$1$的序列，所有元素均为$0$.</p>
</blockquote>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><blockquote>
<p>第一行，两个正整数$n,t$，表示序列的长度和操作个数。<br>接下来$t$行，每行一个操作，格式如<code>题目描述</code>所述。</p>
<p>保证任何输入的数都是<strong>正整数</strong>。</p>
</blockquote>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><blockquote>
<p>对于每一个<code>Q</code>操作，输出一行一个整数，表示对应的区间和。</p>
</blockquote>
<h3 id="样例数据"><a href="#样例数据" class="headerlink" title="样例数据"></a>样例数据</h3><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><blockquote>
<p>5 5<br>A 1 2 3<br>Q 1 1 4<br>C 1<br>A 2 3 2<br>Q 2 1 4</p>
</blockquote>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><blockquote>
<p>3<br>5</p>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><blockquote>
<p>第一次操作后，版本<code>1</code>的序列为：<code>0 3 0 0 0</code>.<br>第二次操作询问版本<code>1</code>的$A_{[1,4]}$区间和，答案为$0+3+0+0=3$.<br>第三次操作将版本<code>1</code>的序列复制到版本<code>2</code>.<br>第四次操作后，版本<code>2</code>的序列为：<code>0 3 2 0 0</code>.<br>第五次操作询问版本<code>2</code>的$A_{[1,4]}$区间和，答案为$0+3+2+0=5$.</p>
</blockquote>
<h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><blockquote>
<p>对于$20\%$的数据，有$n \leq 1000 , m \leq 100$.<br>对于$60\%$的数据，有$n \leq 100000 , m \leq 1000$.<br>对于$100\%$的数据，有$n \leq 1000000 , m \leq 1000000$.</p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote>
<p>100w，直接写主席树会被卡空间。由于每一个版本是从之前的版本“衍生”出来的。所以我们只需要维护一个版本——“当前”的版本。对于修改操作，我们在处理完这个版本之后将它还原；对于查询操作，直接在当前的线段树里面查询；对于衍生操作，我们递归下去。正确性是显然的，这样我们就卡过了空间。把上文的线段树改成树状数组，就可以卡过时间。</p>
</blockquote>
<p>转自<a href="https://www.zhihu.com/question/67046715/answer/248510530" target="_blank" rel="external">阮行止</a></p>
<p>下附我的代码：</p>
<pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;

using namespace std;

typedef long long LL;

inline int Read() {
    char c;
    while (c = getchar(), !isdigit(c));
    int x = c - 48;
    while (c = getchar(), isdigit(c)) x = x * 10 + c - 48;
    return x;
}
inline void Read(int &amp;x) {
    char c;
    while (c = getchar(), !isdigit(c));
    x = c - 48;
    while (c = getchar(), isdigit(c)) x = x * 10 + c - 48;
    return;
}
inline void Writeln(LL x) {
    int k = 0, t[20];
    do t[++k] = x % 10 + 48;
    while (x /= 10);
    while (k) putchar(t[k--]);
    putchar(&#39;\n&#39;);
    return;
}

const int N = 1000010, M = 1000010;

int n, m;
char ch[10];
LL a[N];
inline int Lowbit(int x) {
    return (x) &amp; (-x);
}
void Modify(int x, int k) {
    for (; x &lt;= n; x += Lowbit(x))
        a[x] += k;
    return;
}
LL Sum(int x) {
    LL sum = 0;
    for (; x; x -= Lowbit(x))
        sum += a[x];
    return sum;
}

int tot = -1, head[M], tail[N];
struct Edge {
    int t, x, k, next;
} edge[M];
inline void Add(int u, int t, int x, int k = 0) {
    edge[++tot] = (Edge) {t, x, k, -1};
    if (!~head[u]) head[u] = tot;
    else edge[tail[u]].next = tot;
    tail[u] = tot;
    return;
}
LL res[M];

void DFS(int u) {
    for (int i = head[u]; ~i; i = edge[i].next) {
        int t = edge[i].t;
        if (t == 1) Modify(edge[i].x, edge[i].k);
        else if (t == 2) res[i] = Sum(edge[i].k) - Sum(edge[i].x - 1);
        else DFS(edge[i].x);
    }
    for (int i = head[u]; ~i; i = edge[i].next)
        if (edge[i].t == 1) Modify(edge[i].x, -edge[i].k);
    return;
}

int main() {
    Read(n);
    Read(m);
    memset(head, -1, sizeof(head));
    int cnt = 1;
    for (int i = 1; i &lt;= m; ++i) {
        scanf(&quot;%s&quot;, ch);
        if (ch[0] == &#39;A&#39;) {
            int v = Read(), x = Read(), k = Read();
            Add(v, 1, x, k);
        } else if (ch[0] == &#39;Q&#39;) {
            int v = Read(), l = Read(), r = Read();
            Add(v, 2, l, r);
        } else {
            int v = Read();
            Add(v, 3, ++cnt);
        }
    }
    DFS(1);
    for (int i = 0; i &lt; m; ++i)
        if (edge[i].t == 2) Writeln(res[i]);
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[国家集训队论文分类整理]]></title>
      <url>/2017/10/29/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E8%AE%BA%E6%96%87%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<table style="width: 906px;" border="0" cellspacing="0" cellpadding="0"><colgroup><col width="72"><col width="106"><col width="728"></colgroup>
<tbody>
<tr>
<td rowspan="20" width="72" height="520">组合数学</td>
<td rowspan="4" width="106">计数与统计</td>
<td width="728">2001 - 符文杰：《P&oacute;lya原理及其应用》</td>
</tr>
<tr>
<td width="728" height="26">2003 - 许智磊：《浅谈补集转化思想在统计问题中的应用》</td>
</tr>
<tr>
<td width="728" height="26">2007 - 周冬：《生成树的计数及其应用》</td>
</tr>
<tr>
<td width="728" height="26">2008 - 陈瑜希《P&oacute;lya计数法的应用》</td>
</tr>
<tr>
<td rowspan="2" height="52">数位问题</td>
<td width="728">2009 - 高逸涵《数位计数问题解法研究》</td>
</tr>
<tr>
<td width="728" height="26">2009 - 刘聪《浅谈数位类统计问题》</td>
</tr>
<tr>
<td rowspan="2" height="52">动态统计</td>
<td width="728">2004 - 薛矛：《解决动态统计问题的两把利刃》</td>
</tr>
<tr>
<td width="728" height="26">2007 - 余江伟：《如何解决动态统计问题》</td>
</tr>
<tr>
<td rowspan="5" height="130">博弈</td>
<td width="728">2002 - 张一飞：《由感性认识到理性认识&mdash;&mdash;透析一类搏弈游戏的解答过程》</td>
</tr>
<tr>
<td width="728" height="26">2007 - 王晓珂：《解析一类组合游戏》</td>
</tr>
<tr>
<td width="728" height="26">2009 - 曹钦翔《从&ldquo;k倍动态减法游戏&rdquo;出发探究一类组合游戏问题》</td>
</tr>
<tr>
<td width="728" height="26">2009 - 方展鹏《浅谈如何解决不平等博弈问题》</td>
</tr>
<tr>
<td width="728" height="26">2009 - 贾志豪《组合游戏略述&mdash;&mdash;浅谈SG游戏的若干拓展及变形》</td>
</tr>
<tr>
<td height="26">母函数</td>
<td width="728">2009 - 毛杰明《母函数的性质及应用》</td>
</tr>
<tr>
<td height="26">拟阵</td>
<td width="728">2007 - 刘雨辰：《对拟阵的初步研究》</td>
</tr>
<tr>
<td height="26">线性规划</td>
<td width="728">2007 - 李宇骞：《浅谈信息学竞赛中的线性规划&mdash;&mdash;简洁高效的单纯形法实现与应用》</td>
</tr>
<tr>
<td height="26">置换群</td>
<td width="728">2005 - 潘震皓：《置换群快速幂运算研究与探讨》</td>
</tr>
<tr>
<td height="26">问答交互</td>
<td width="728">2003 - 高正宇：《答案只有一个&mdash;&mdash;浅谈问答式交互问题》&nbsp;</td>
</tr>
<tr>
<td rowspan="2" height="52">猜数问题</td>
<td width="728">2003 - 张宁：《猜数问题的研究:&lt;聪明的学生&gt;一题的推广》</td>
</tr>
<tr>
<td width="728" height="26">2006 - 龙凡：《一类猜数问题的研究》</td>
</tr>
<tr>
<td rowspan="19" height="494">数据结构</td>
<td rowspan="4">数据结构</td>
<td width="728">2005 - 何林：《数据关系的简化》</td>
</tr>
<tr>
<td width="728" height="26">2006 - 朱晨光：《基本数据结构在信息学竞赛中的应用》</td>
</tr>
<tr>
<td width="728" height="26">2007 - 何森：《浅谈数据的合理组织》</td>
</tr>
<tr>
<td width="728" height="26">2008 - 曹钦翔《数据结构的提炼与压缩》</td>
</tr>
<tr>
<td rowspan="2" height="52">结构联合</td>
<td width="728">2001 - 高寒蕊：《从圆桌问题谈数据结构的综合运用》</td>
</tr>
<tr>
<td width="728" height="26">2005 - 黄刚：《数据结构的联合》</td>
</tr>
<tr>
<td rowspan="2" height="52">块状链表</td>
<td width="728">2005 - 蒋炎岩：《数据结构的联合&mdash;&mdash;块状链表》</td>
</tr>
<tr>
<td width="728" height="26">2008 - 苏煜《对块状链表的一点研究》</td>
</tr>
<tr>
<td rowspan="2" height="52">动态树</td>
<td width="728">2006 - 陈首元：《维护森林连通性&mdash;&mdash;动态树》</td>
</tr>
<tr>
<td width="728" height="26">2007 - 袁昕颢：《动态树及其应用》</td>
</tr>
<tr>
<td height="26">左偏树</td>
<td width="728">2005 - 黄源河：《左偏树的特点及其应用》</td>
</tr>
<tr>
<td rowspan="2" height="52">跳表</td>
<td width="728">2005 - 魏冉：《让算法的效率&ldquo;跳起来&rdquo;！&mdash;&mdash;浅谈&ldquo;跳跃表&rdquo;的相关操作及其应用》</td>
</tr>
<tr>
<td width="728" height="26">2009 - 李骥扬《线段跳表&mdash;&mdash;跳表的一个拓展》</td>
</tr>
<tr>
<td height="26">SBT</td>
<td width="728">2007 - 陈启峰：《Size Balance Tree》</td>
</tr>
<tr>
<td height="26">线段树</td>
<td width="728">2004 - 林涛：《线段树的应用》</td>
</tr>
<tr>
<td height="26">单调队列</td>
<td width="728">2006 - 汤泽：《浅析队列在一类单调性问题中的应用》</td>
</tr>
<tr>
<td rowspan="2" height="52">哈希表</td>
<td width="728">2005 - 李羽修：《Hash函数的设计优化》</td>
</tr>
<tr>
<td width="728" height="26">2007 - 杨弋：《Hash在信息学竞赛中的一类应用》</td>
</tr>
<tr>
<td height="26">Splay</td>
<td width="728">2004 - 杨思雨：《伸展树的基本操作与应用》</td>
</tr>
<tr>
<td rowspan="21" height="546">图论</td>
<td>图论</td>
<td width="728">2005 - 任恺：《图论的基本思想及方法》</td>
</tr>
<tr>
<td rowspan="2" height="52">模型建立</td>
<td width="728">2004 - 黄源河：《浅谈图论模型的建立与应用》</td>
</tr>
<tr>
<td width="728" height="26">2004 - 肖天：《&ldquo;分层图思想&rdquo;及其在信息学竞赛中的应用》</td>
</tr>
<tr>
<td rowspan="5" height="130">网络流</td>
<td width="728">2001 - 江鹏：《从一道题目的解法试谈网络流的构造与算法》</td>
</tr>
<tr>
<td width="728" height="26">2002 - 金恺：《浅谈网络流算法的应用》</td>
</tr>
<tr>
<td width="728" height="26">2007 - 胡伯涛：《最小割模型在信息学竞赛中的应用》</td>
</tr>
<tr>
<td width="728" height="26">2007 - 王欣上：《浅谈基于分层思想的网络流算法》</td>
</tr>
<tr>
<td width="728" height="26">2008 - 周冬《两极相通&mdash;&mdash;浅析最大&mdash;最小定理在信息学竞赛中的应用》</td>
</tr>
<tr>
<td rowspan="3" height="78">最短路</td>
<td width="728">2006 - 余远铭：《最短路算法及其应用》</td>
</tr>
<tr>
<td width="728" height="26">2008 - 吕子鉷《浅谈最短径路问题中的分层思想》</td>
</tr>
<tr>
<td width="728" height="26">2009 - 姜碧野《SPFA算法的优化及应用》</td>
</tr>
<tr>
<td height="26">欧拉路</td>
<td width="728">2007 - 仇荣琦：《欧拉回路性质与应用探究》</td>
</tr>
<tr>
<td height="26">差分约束系统</td>
<td width="728">2006 - 冯威：《数与图的完美结合&mdash;&mdash;浅析差分约束系统》</td>
</tr>
<tr>
<td rowspan="2" height="52">平面图</td>
<td width="728">2003 - 刘才良：《平面图在信息学中的应用》</td>
</tr>
<tr>
<td width="728" height="26">2007 - 古楠：《平面嵌入》</td>
</tr>
<tr>
<td height="26">2-SAT</td>
<td width="728">2003 - 伍昱：《由对称性解2-SAT问题》</td>
</tr>
<tr>
<td rowspan="2" height="52">最小生成树</td>
<td width="728">2004 - 吴景岳：《最小生成树算法及其应用》</td>
</tr>
<tr>
<td width="728" height="26">2004 - 汪汀：《最小生成树问题的拓展》</td>
</tr>
<tr>
<td height="26">二分图</td>
<td width="728">2005 - 王俊：《浅析二分图匹配在信息学竞赛中的应用》</td>
</tr>
<tr>
<td height="26">Voronoi图</td>
<td width="728">2006 - 王栋：《浅析平面Voronoi图的构造及应用》</td>
</tr>
<tr>
<td height="26">偶图</td>
<td width="728">2002 - 孙方成：《偶图的算法及应用》</td>
</tr>
<tr>
<td rowspan="5" height="130">树</td>
<td rowspan="2">树</td>
<td width="728">2002 - 周文超：《树结构在程序设计中的运用》</td>
</tr>
<tr>
<td width="728" height="26">2005 - 栗师：《树的乐园&mdash;&mdash;一些与树有关的题目》</td>
</tr>
<tr>
<td height="26">路径问题</td>
<td width="728">2009 - 漆子超《分治算法在树的路径问题中的应用》</td>
</tr>
<tr>
<td height="26">最近公共祖先</td>
<td width="728">2007 - 郭华阳：《RMQ与LCA问题》</td>
</tr>
<tr>
<td height="26">划分问题</td>
<td width="728">2004 - 贝小辉：《浅析树的划分问题》</td>
</tr>
<tr>
<td rowspan="2" height="52">数论</td>
<td>欧几里得算法</td>
<td width="728">2009 - 金斌《欧几里得算法的应用》</td>
</tr>
<tr>
<td height="26">同余方程</td>
<td width="728">2003 - 姜尚仆：《模线性方程的应用&mdash;&mdash;用数论方法解决整数问题》</td>
</tr>
<tr>
<td rowspan="9" height="234">搜索</td>
<td rowspan="3">搜索</td>
<td width="728">2001 - 骆骥：《由&ldquo;汽车问题&rdquo;浅谈深度搜索的一个方面&mdash;&mdash;搜索对象与策略的重要性》</td>
</tr>
<tr>
<td width="728" height="26">2002 - 王知昆：《搜索顺序的选择》</td>
</tr>
<tr>
<td width="728" height="26">2005 - 汪汀：《参数搜索的应用》</td>
</tr>
<tr>
<td height="26">启发式</td>
<td width="728">2009 - 周而进《浅谈估价函数在信息学竞赛中的应用》</td>
</tr>
<tr>
<td rowspan="3" height="78">优化</td>
<td width="728">2003 - 金恺：《探寻深度优先搜索中的优化技巧&mdash;&mdash;从正方形剖分问题谈起》</td>
</tr>
<tr>
<td width="728" height="26">2003 - 刘一鸣：《一类搜索的优化思想&mdash;&mdash;数据有序化》</td>
</tr>
<tr>
<td width="728" height="26">2006 - 黄晓愉：《深度优先搜索问题的优化技巧》</td>
</tr>
<tr>
<td height="26">背包问题</td>
<td width="728">2009 - 徐持衡《浅谈几类背包题》</td>
</tr>
<tr>
<td height="26">匹配</td>
<td width="728">2004 - 楼天城：《匹配算法在搜索问题中的巧用》</td>
</tr>
<tr>
<td rowspan="2" height="52">概率</td>
<td>概率</td>
<td width="728">2009 - 梅诗珂《信息学竞赛中概率问题求解初探》</td>
</tr>
<tr>
<td height="26">数学期望</td>
<td width="728">2009 - 汤可因《浅析竞赛中一类数学期望问题的解决方法》</td>
</tr>
<tr>
<td rowspan="8" height="208">字符串</td>
<td>字符串</td>
<td width="728">2003 - 周源：《浅析&ldquo;最小表示法&rdquo;思想在字符串循环同构问题中的应用》</td>
</tr>
<tr>
<td rowspan="3" height="78">多串匹配</td>
<td width="728">2004 - 朱泽园：《多串匹配算法及其启示》</td>
</tr>
<tr>
<td width="728" height="26">2006 - 王赟：《Trie图的构建、活用与改进》</td>
</tr>
<tr>
<td width="728" height="26">2009 - 董华星《浅析字母树在信息学竞赛中的应用》</td>
</tr>
<tr>
<td rowspan="2" height="52">后缀数组</td>
<td width="728">2004 - 许智磊：《后缀数组》</td>
</tr>
<tr>
<td width="728" height="26">2009 - 罗穗骞《后缀数组&mdash;&mdash;处理字符串的有力工具》</td>
</tr>
<tr>
<td rowspan="2" height="52">字符串匹配</td>
<td width="728">2003 - 饶向荣：《病毒的DNA&mdash;&mdash;&mdash;剖析一道字符匹配问题解析过程》</td>
</tr>
<tr>
<td width="728" height="26">2003 - 林希德：《求最大重复子串》</td>
</tr>
<tr>
<td rowspan="10" height="260">动态规划</td>
<td rowspan="3">动态规划</td>
<td width="728">2001 - 俞玮：《基本动态规划问题的扩展》</td>
</tr>
<tr>
<td width="728" height="26">2006 - 黄劲松：《贪婪的动态规划》</td>
</tr>
<tr>
<td width="728" height="26">2009 - 徐源盛《对一类动态规划问题的研究》</td>
</tr>
<tr>
<td height="26">状态压缩</td>
<td width="728">2008 - 陈丹琦《基于连通性状态压缩的动态规划问题》</td>
</tr>
<tr>
<td height="26">状态设计</td>
<td width="728">2008 - 刘弈《浅谈信息学中状态的合理设计与应用》</td>
</tr>
<tr>
<td height="26">树形DP</td>
<td width="728">2007 - 陈瑜希：《多角度思考创造性思维&mdash;&mdash;运用树型动态规划解题的思路和方法探析》</td>
</tr>
<tr>
<td rowspan="4" height="104">优化</td>
<td width="728">2001 - 毛子青：《动态规划算法的优化技巧》</td>
</tr>
<tr>
<td width="728" height="26">2003 - 项荣璟：《充分利用问题性质&mdash;&mdash;例析动态规划的&ldquo;个性化&rdquo;优化》</td>
</tr>
<tr>
<td width="728" height="26">2004 - 朱晨光：《优化，再优化！&mdash;&mdash;从《鹰蛋》一题浅析对动态规划算法的优化》</td>
</tr>
<tr>
<td width="728" height="26">2007 - 杨哲：《凸完全单调性的加强与应用》</td>
</tr>
<tr>
<td rowspan="8" height="208">计算几何</td>
<td rowspan="2">立体几何</td>
<td width="728">2003 - 陆可昱：《长方体体积并》</td>
</tr>
<tr>
<td width="728" height="26">2008 - 高亦陶《从立体几何问题看降低编程复杂度》</td>
</tr>
<tr>
<td rowspan="3" height="78">计算几何思想</td>
<td width="728">2004 - 金恺：《极限法&mdash;&mdash;解决几何最优化问题的捷径》</td>
</tr>
<tr>
<td width="728" height="26">2008 - 程芃祺《计算几何中的二分思想》</td>
</tr>
<tr>
<td width="728" height="26">2008 - 顾研《浅谈随机化思想在几何问题中的应用》</td>
</tr>
<tr>
<td height="26">圆</td>
<td width="728">2007 - 高逸涵：《与圆有关的离散化》</td>
</tr>
<tr>
<td rowspan="2" height="52">半平面交</td>
<td width="728">2002 - 李澎煦：《半平面交的算法及其应用》</td>
</tr>
<tr>
<td width="728" height="26">2006 - 朱泽园：《半平面交的新算法及其实用价值》</td>
</tr>
<tr>
<td rowspan="2" height="52">矩阵</td>
<td>矩阵</td>
<td width="728">2008 - 俞华程《矩阵乘法在信息学中的应用》</td>
</tr>
<tr>
<td height="26">高斯消元</td>
<td width="728">2002 - 何江舟：《用高斯消元法解线性方程组》</td>
</tr>
<tr>
<td rowspan="6" height="156">数学方法</td>
<td rowspan="2">数学思想</td>
<td width="728">2002 - 何林：《猜想及其应用》</td>
</tr>
<tr>
<td width="728" height="26">2003 - 邵烜程：《数学思想助你一臂之力》</td>
</tr>
<tr>
<td height="26">数学归纳法</td>
<td width="728">2009 - 张昆玮《数学归纳法与解题之道》</td>
</tr>
<tr>
<td height="26">多项式</td>
<td width="728">2002 - 张家琳：《多项式乘法》</td>
</tr>
<tr>
<td height="26">数形结合</td>
<td width="728">2004 - 周源：《浅谈数形结合思想在信息学竞赛中的应用》</td>
</tr>
<tr>
<td height="26">黄金分割</td>
<td width="728">2005 - 杨思雨：《美，无处不在&mdash;&mdash;浅谈&ldquo;黄金分割&rdquo;和信息学的联系》</td>
</tr>
<tr>
<td rowspan="5" height="130">其他算法</td>
<td rowspan="2">遗传算法</td>
<td width="728">2002 - 张宁：《遗传算法的特点及其应用》</td>
</tr>
<tr>
<td width="728" height="26">2005 - 钱自强：《关于遗传算法应用的分析与研究》</td>
</tr>
<tr>
<td height="26">信息论</td>
<td width="728">2003 - 侯启明：《信息论在信息学竞赛中的简单应用》</td>
</tr>
<tr>
<td rowspan="2" height="52">染色与构造</td>
<td width="728">2002 - 杨旻旻：《构造法&mdash;&mdash;解题的最短路径》</td>
</tr>
<tr>
<td width="728" height="26">2003 - 方奇：《染色法和构造法在棋盘上的应用》</td>
</tr>
<tr>
<td rowspan="6" height="156">一类问题</td>
<td>区间</td>
<td width="728">2008 - 周小博《浅谈信息学竞赛中的区间问题》</td>
</tr>
<tr>
<td height="26">序</td>
<td width="728">2005 - 龙凡：《序的应用》</td>
</tr>
<tr>
<td height="26">系</td>
<td width="728">2006 - 汪晔：《信息学中的参考系与坐标系》</td>
</tr>
<tr>
<td height="26">物理问题</td>
<td width="728">2008 - 方戈《浅析信息学竞赛中一类与物理有关的问题》</td>
</tr>
<tr>
<td height="26">编码与译码</td>
<td width="728">2008 - 周梦宇《码之道&mdash;浅谈信息学竞赛中的编码与译码问题》</td>
</tr>
<tr>
<td height="26">对策问题</td>
<td width="728">2002 - 骆骥：《浅析解&ldquo;对策问题&rdquo;的两种思路》</td>
</tr>
<tr>
<td rowspan="6" height="156">优化</td>
<td rowspan="4">算法优化</td>
<td width="728">2002 - 孙林春：《让我们做得更好&mdash;&mdash;从解法谈程序优化》</td>
</tr>
<tr>
<td width="728" height="26">2004 - 胡伟栋：《减少冗余与算法优化》</td>
</tr>
<tr>
<td width="728" height="26">2005 - 杨弋：《从&lt;小H的小屋&gt;的解法谈算法的优化》</td>
</tr>
<tr>
<td width="728" height="26">2006 - 贾由：《由图论算法浅析算法优化》</td>
</tr>
<tr>
<td rowspan="2" height="52">程序优化</td>
<td width="728">2006 - 周以苏：《论反汇编在时间常数优化中的应用》</td>
</tr>
<tr>
<td width="728" height="26">2009 - 骆可强《论程序底层优化的一些方法与技巧》</td>
</tr>
<tr>
<td height="26">语言</td>
<td>C++</td>
<td width="728">2004 - 韩文弢：《论C++语言在信息学竞赛中的应用》</td>
</tr>
<tr>
<td rowspan="27" height="702">策略</td>
<td rowspan="6">策略</td>
<td width="728">2004 - 李锐喆：《细节&mdash;&mdash;不可忽视的要素》</td>
</tr>
<tr>
<td width="728" height="26">2005 - 朱泽园：《回到起点&mdash;&mdash;一种突破性思维》</td>
</tr>
<tr>
<td width="728" height="26">2006 - 陈启峰：《&ldquo;约制、放宽&rdquo;方法在解题中的应用》</td>
</tr>
<tr>
<td width="728" height="26">2006 - 李天翼：《从特殊情况考虑》</td>
</tr>
<tr>
<td width="728" height="26">2007 - 陈雪：《问题中的变与不变》</td>
</tr>
<tr>
<td width="728" height="26">2008 - 肖汉骏《例谈信息学竞赛分析中的&ldquo;深&rdquo;与&ldquo;广&rdquo;》</td>
</tr>
<tr>
<td height="26">倍增</td>
<td width="728">2005 - 朱晨光：《浅析倍增思想在信息学竞赛中的应用》</td>
</tr>
<tr>
<td rowspan="3" height="78">二分</td>
<td width="728">2002 - 李睿：《二分法与统计问题》</td>
</tr>
<tr>
<td width="728" height="26">2002 - 许智磊：《二分，再二分！&mdash;&mdash;从Mobiles(IOI2001)一题看多重二分》</td>
</tr>
<tr>
<td width="728" height="26">2005 - 杨俊：《二分策略在信息学竞赛中的应用》</td>
</tr>
<tr>
<td height="26">调整</td>
<td width="728">2006 - 唐文斌：《&ldquo;调整&rdquo;思想在信息学中的应用》</td>
</tr>
<tr>
<td height="26">随机化</td>
<td width="728">2007 - 刘家骅：《浅谈随机化在信息学竞赛中的应用》</td>
</tr>
<tr>
<td rowspan="2" height="52">非完美算法</td>
<td width="728">2005 - 胡伟栋：《浅析非完美算法在信息学竞赛中的应用》</td>
</tr>
<tr>
<td width="728" height="26">2008 - 任一恒《非完美算法初探》</td>
</tr>
<tr>
<td height="26">提交答案题</td>
<td width="728">2003 - 雷环中：《结果提交类问题》</td>
</tr>
<tr>
<td height="26">守恒思想</td>
<td width="728">2004 - 何林：《信息学中守恒法的应用》</td>
</tr>
<tr>
<td height="26">极限法</td>
<td width="728">2003 - 王知昆：《浅谈用极大化思想解决最大子矩形问题》</td>
</tr>
<tr>
<td height="26">贪心</td>
<td width="728">2008 - 高逸涵《部分贪心思想在信息学竞赛中的应用》</td>
</tr>
<tr>
<td height="26">压缩法</td>
<td width="728">2005 - 周源：《压去冗余缩得精华&mdash;&mdash;浅谈信息学竞赛中的&ldquo;压缩法&rdquo;》</td>
</tr>
<tr>
<td height="26">逆向思维</td>
<td width="728">2005 - 唐文斌：《正难则反&mdash;&mdash;浅谈逆向思维在解题中的应用》</td>
</tr>
<tr>
<td height="26">穷举</td>
<td width="728">2004 - 鬲融：《浅谈特殊穷举思想的应用》</td>
</tr>
<tr>
<td rowspan="2" height="52">目标转换</td>
<td width="728">2002 - 戴德承：《退一步海阔天空&mdash;&mdash;&ldquo;目标转化思想&rdquo;的若干应用》</td>
</tr>
<tr>
<td width="728" height="26">2004 - 栗师：《转化目标在解题中的应用》</td>
</tr>
<tr>
<td height="26">类比</td>
<td width="728">2006 - 周戈林：《浅谈类比思想》</td>
</tr>
<tr>
<td rowspan="2" height="52">分割与合并</td>
<td width="728">2006 - 俞鑫：《棋盘中的棋盘&mdash;&mdash;浅谈棋盘的分割思想》</td>
</tr>
<tr>
<td width="728" height="26">2007 - 杨沐：《浅析信息学中的&ldquo;分&rdquo;与&ldquo;合&rdquo;》</td>
</tr>
<tr>
<td height="26">平衡思想</td>
<td width="728">2008 - 郑暾《平衡规划&mdash;&mdash;浅析一类平衡思想的应用》</td>
</tr>
</tbody>
</table>

<p>转自<a href="http://www.cnblogs.com/AbandonZHANG/archive/2012/07/21/2601889.html" target="_blank" rel="external">国家集训队论文分类整理</a></p>
]]></content>
      
        <categories>
            
            <category> 国家集训队论文 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[51Nod1273]]></title>
      <url>/2017/10/27/51Nod1273/</url>
      <content type="html"><![CDATA[<h1 id="旅行计划"><a href="#旅行计划" class="headerlink" title="旅行计划"></a><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1273" target="_blank" rel="external">旅行计划</a></h1><p><center> 基准时间限制：1 秒 空间限制：131072 KB 分值: 80 难度：5级算法题</center></p>
<h2 id="Description"><a href="#Description" class="headerlink" title=" Description "></a><strong> Description </strong></h2><blockquote>
<p>某个国家有$N$个城市，编号$0$至$N - 1$，他们之间用$N - 1$条道路连接，道路是双向行驶的，沿着道路你可以到达任何一个城市。你有一个旅行计划，这个计划是从编号$K$的城市出发，每天到达一个你没有去过的城市，并且旅途中经过的没有去过的城市尽可能的多（如果有$2$条路线，经过的没有去过的城市同样多，优先考虑编号最小的城市），直到所有城市都观光过一遍。现在给出城市之间的交通图$T$，以及出发地点$K$，你来设计一个旅行计划，满足上面的条件。例如：<br>($K = 2$)<br><img src="/img/post/51Nod1273_1.png" alt=""><br>第$1$天 从$2$到$0$ (城市$1$和$0$变成去过的)<br>第$2$天 从$0$到$6$ (城市$4$和$6$变成去过的)<br>第$3$天 从$6$到$3$ (城市$3$变成去过的)<br>第$4$天 从$3$到$5$ (城市$5$变成去过的)<br>上图的输入数据为：$0 1 2 2 1 4$。共$7$个节点，除节点$0$之外，共$6$行数据。<br>第$1$个数$0$表示$1$到$0$有$1$条道路。<br>第$2$个数$1$表示$2$到$1$有$1$条道路。</p>
</blockquote>
<h2 id="Input"><a href="#Input" class="headerlink" title=" Input "></a><strong> Input </strong></h2><blockquote>
<p>第$1$行：$2$个数$N$，$K$($1 \le N \le 50000, 0 \le K \le N - 1$)<br>第$2 - N + 1$行：每行一个数，表示节点之间的道路。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title=" Output "></a><strong> Output </strong></h2><blockquote>
<p>输出旅行的路线图，即每天到达的城市编号。</p>
</blockquote>
<h2 id="Input示例"><a href="#Input示例" class="headerlink" title=" Input示例 "></a><strong> Input示例 </strong></h2><blockquote>
<p>7 2<br>0<br>1<br>2<br>2<br>1<br>4</p>
</blockquote>
<h2 id="Output示例"><a href="#Output示例" class="headerlink" title=" Output示例 "></a><strong> Output示例 </strong></h2><blockquote>
<p>2<br>0<br>6<br>3<br>5</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title=" Solution "></a><strong> Solution </strong></h2><blockquote>
<p>以下搬自51nod题解。考虑将树根设为K，观察到以下结论：</p>
<ol>
<li>每次必然会走到叶子，否则可以继续向下走到叶子，使得访问的点增多。</li>
<li>考虑每次访问到的未访问的点，一定是与叶子相连的、在叶子到点K路径上的一条连续的链，所以问题可以转化为：令每个叶子分别支配一条链，使得标号小的点尽量支配多的点，最后根据支配的点数多少、标号大小依次访问。以做法可以是树上贪心，从深到浅依次确定每个点被其子树里哪个叶子支配，然后使得那个点的支配点个数加一，最后用基数排序排出支配点数降序、标号大小升序即可。</li>
</ol>
<p>然而我看不懂这个题解，我的做法是这样的：先$DFS$一遍，算出以每棵子树最深的深度，然后维护一个根连接的子树的优先队列，每次取出一棵深度最大的子树，走到这棵子树的最深的节点，这里的根并不只是$k$，而是已经被访问过的点。每次选择一个点后，把这条路径上新产生的子树加入优先队列中。时间复杂度$O(nlog_2{n})$。</p>
</blockquote>
<h2 id="Standard"><a href="#Standard" class="headerlink" title=" Standard "></a><strong> Standard </strong></h2><pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

#define fi first
#define se second
#define mp make_pair

typedef pair&lt;int, int&gt; PII;

const int N = 50010;

int n, k;

int tot = -1, head[N];
struct Edge {
    int p, next;
} edge[N &lt;&lt; 1];
inline void Add(int u, int v) {
    edge[++tot] = (Edge) {v, head[u]};
    head[u] = tot;
    return;
}

int fa[N];
PII md[N];

void DFS(int u) {
    md[u] = mp(1, -u);
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].p;
        if (v == fa[u]) continue;
        fa[v] = u;
        DFS(v);
        PII cur = md[v];
        ++cur.fi;
        if (md[u] &lt; cur) md[u] = cur;
    }
    return;
}

priority_queue&lt;PII&gt; pq;
bool exist[N];

void Update(int u) {
    for (; ~u &amp;&amp; !exist[u]; u = fa[u]) {
        exist[u] = 1;
        for (int i = head[u]; ~i; i = edge[i].next) {
            int v = edge[i].p;
            if (v == fa[u]) continue;
            if (!exist[v]) pq.push(md[v]);
        }
    }
    return;
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    memset(head, -1, sizeof(head));
    for (int u = 1; u &lt; n; ++u) {
        int v;
        scanf(&quot;%d&quot;, &amp;v);
        Add(u, v);
        Add(v, u);
    }
    fa[k] = -1;
    DFS(k);
    for (int i = head[k]; ~i; i = edge[i].next) {
        int v = edge[i].p;
        pq.push(md[v]);
    }
    exist[k] = 1;
    printf(&quot;%d\n&quot;, k);
    while (!pq.empty()) {
        PII cur = pq.top();
        pq.pop();
        int u = -cur.se;
        Update(u);
        printf(&quot;%d\n&quot;, u);
    }
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 51Nod </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51Nod1103]]></title>
      <url>/2017/10/27/51Nod1103/</url>
      <content type="html"><![CDATA[<h1 id="N的倍数"><a href="#N的倍数" class="headerlink" title="N的倍数"></a><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1103" target="_blank" rel="external">N的倍数</a></h1><p><center> 基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题</center></p>
<h2 id="Description"><a href="#Description" class="headerlink" title=" Description "></a><strong> Description </strong></h2><blockquote>
<p>一个长度为$N$的数组$A$，从$A$中选出若干个数，使得这些数的和是$N$的倍数。<br>例如：$N = 8$，数组$A$包括：$2 5 6 3 18 7 11 19$，可以选$2 6$，因为$2 + 6 = 8$，是$8$的倍数。</p>
</blockquote>
<h2 id="Input"><a href="#Input" class="headerlink" title=" Input "></a><strong> Input </strong></h2><blockquote>
<p>第$1$行：$1$个数$N$，$N$为数组的长度，同时也是要求的倍数。($2 \le N \le 50000$)<br>第$2 - N + 1$行：数组$A$的元素。($0 \lt A[i] \le 10^9$)</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title=" Output "></a><strong> Output </strong></h2><blockquote>
<p>如果没有符合条件的组合，输出$No \  Solution$。<br>第$1$行：$1$个数$S$表示你所选择的数的数量。<br>第$2 - S + 1$行：每行$1$个数，对应你所选择的数。</p>
</blockquote>
<h2 id="Input示例"><a href="#Input示例" class="headerlink" title=" Input示例 "></a><strong> Input示例 </strong></h2><blockquote>
<p>8<br>2<br>5<br>6<br>3<br>18<br>7<br>11<br>19</p>
</blockquote>
<h2 id="Output示例"><a href="#Output示例" class="headerlink" title=" Output示例 "></a><strong> Output示例 </strong></h2><blockquote>
<p>2<br>2<br>6</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title=" Solution "></a><strong> Solution </strong></h2><blockquote>
<p>我们记$sum_i = \sum_{j = 1}^i{a_j}$，若对于某个$i$，$sum_i$为$n$的倍数，那么原序列的$[1, i]$即为答案。否则，对于$sum_i \  (1 \le i \le n)$这$n$个数，因为它们模$n$的余数在$[1, n - 1]$范围内，所以肯定存在$i,j \  (1 \le i \lt j \le n)$满足$sum_i % n = sum_j% n $，那么原序列的$[i + 1, j]$即为答案。</p>
</blockquote>
<h2 id="Standard"><a href="#Standard" class="headerlink" title=" Standard "></a><strong> Standard </strong></h2><pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

const int N = 50010;

int n;
int a[N], app[N];

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, &amp;a[i]);
    int sum = 0;
    for (int i = 1; i &lt;= n; ++i) {
        sum = (sum + a[i]) % n;
        if (!sum) {
            printf(&quot;%d\n&quot;, i);
            for (int j = 1; j &lt;= i; ++j)
                printf(&quot;%d\n&quot;, a[j]);
            return 0;
        }
        if (app[sum]) {
            printf(&quot;%d\n&quot;, i - app[sum]);
            for (int j = app[sum] + 1; j &lt;= i; ++j)
                printf(&quot;%d\n&quot;, a[j]);
            return 0;
        }
        app[sum] = i;
    }
    puts(&quot;No Solution&quot;); //tan 90°
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 51Nod </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BZOJ3709]]></title>
      <url>/2017/10/26/BZOJ3709/</url>
      <content type="html"><![CDATA[<h1 id="PA2014-Bohater"><a href="#PA2014-Bohater" class="headerlink" title="[PA2014]Bohater"></a><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3709" target="_blank" rel="external">[PA2014]Bohater</a></h1><p><center> Time Limit: 5 Sec  Memory Limit: 128 MB  Special Judge</center></p>
<h2 id="Description"><a href="#Description" class="headerlink" title=" Description "></a><strong> Description </strong></h2><blockquote>
<p>在一款电脑游戏中，你需要打败$n$只怪物（从$1$到$n$编号）。为了打败第$i$只怪物，你需要消耗$d_i$点生命值，但怪物死后会掉落血药，使你恢复$a_i$点生命值。任何时候你的生命值都不能降到$0$（或$0$以下）。请问是否存在一种打怪顺序，使得你可以打完这$n$只怪物而不死掉。</p>
</blockquote>
<h2 id="Input"><a href="#Input" class="headerlink" title=" Input "></a><strong> Input </strong></h2><blockquote>
<p>第一行两个整数$n,z$($1 \le n,z \le 100000$)，分别表示怪物的数量和你的初始生命值。<br>接下来$n$行，每行两个整数$d_i,a_i$($0 \le d_i,a_i \le 100000$)。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title=" Output "></a><strong> Output </strong></h2><blockquote>
<p>第一行为$TAK$（是）或$NIE$（否），表示是否存在这样的顺序。<br>如果第一行为$TAK$，则第二行为空格隔开的$1~n$的排列，表示合法的顺序。如果答案有很多，你可以输出其中任意一个。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title=" Sample Input "></a><strong> Sample Input </strong></h2><blockquote>
<p>3 5<br>3 1<br>4 8<br>8 3</p>
</blockquote>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title=" Sample Output "></a><strong> Sample Output </strong></h2><blockquote>
<p>TAK<br>2 3 1</p>
</blockquote>
<h2 id="HINT"><a href="#HINT" class="headerlink" title=" HINT "></a><strong> HINT </strong></h2><h2 id="Solution"><a href="#Solution" class="headerlink" title=" Solution "></a><strong> Solution </strong></h2><blockquote>
<p>把怪物分成两种，一种是$d_i \le a_i$，另一种$d_i \gt a_i$。<br>对于第一种，我们按$d_i$从小到大打，若某个怪兽打不掉了，那么不存在方案。这种贪心的正确性显而易见。<br>对于第二种，我们按$a_i$从大到小打，若某个怪兽打不掉了，那么不存在方案。那么我来证明一下这个的正确性。我们知道，打完所有的怪兽后的生命值是固定的，那么我们考虑从最后的生命值反着退回来，那么此时的就是先减去$a_i$，再加上$d_i$，如此下去。此时$a_i \lt d_i$，这么倒着做是不是与第一种情况一样？所以我们倒着按$a_i$从小到大做，就相当于正着按$a_i$从大到小做。</p>
</blockquote>
<h2 id="Standard"><a href="#Standard" class="headerlink" title=" Standard "></a><strong> Standard </strong></h2><pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
LL rest;
int a[N], b[N];
vector&lt;int&gt; ge, le;

bool Cmp1(int x, int y) {
    return a[x] &lt; a[y];
}
bool Cmp2(int x, int y) {
    return b[x] &gt; b[y];
}

int main() {
    scanf(&quot;%d%lld&quot;, &amp;n, &amp;rest);
    for (int i = 1; i &lt;= n; ++i) {
        scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]);
        if (a[i] &lt;= b[i]) ge.push_back(i);
        else le.push_back(i);
    }
    sort(ge.begin(), ge.end(), Cmp1);
    sort(le.begin(), le.end(), Cmp2);
    for (int i = 0; i &lt; (int)ge.size(); ++i) {
        if (rest &lt;= a[ge[i]]) {
            puts(&quot;NIE&quot;);
            return 0;
        }
        rest += -a[ge[i]] + b[ge[i]];
    }
    for (int i = 0; i &lt; (int)le.size(); ++i) {
        if (rest &lt;= a[le[i]]) {
            puts(&quot;NIE&quot;);
            return 0;
        }
        rest += -a[le[i]] + b[le[i]];
    }
    puts(&quot;TAK&quot;);
    for (int i = 0; i &lt; (int)ge.size(); ++i)
        printf(&quot;%d &quot;, ge[i]);
    for (int i = 0; i &lt; (int)le.size(); ++i)
        printf(&quot;%d &quot;, le[i]);
    putchar(&#39;\n&#39;);
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> BZOJ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线段树]]></title>
      <url>/2017/10/23/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title=" 前言 "></a><strong> 前言 </strong></h3><p>假如你有一个数组$a$，现要多次询问区间和$\sum_{i=l}^r{a_i}$。<br>如果是不带修改的，那么可以前缀和，$sum_i = \sum_{j = 1}^i{a_j}$，那么$\sum_{i = l}^r{a_i} = sum_r - sum_{l - 1}$。这是预处理$O(n)$，单次询问$O(1)$。<br>那么如果要支持修改呢？显然是不能用前缀和了。<br>这里给出一种思想，就是在询问之前对数组进行一些预处理，且是对任意询问是有用的，以来降低后面单个询问的复杂度。前面的前缀和其实就是这种思想简单的一种。</p>
<p><br><br></p>
<h3 id="简介"><a href="#简介" class="headerlink" title=" 简介 "></a><strong> 简介 </strong></h3><p>这里介绍一种新的数据结构——线段树。<br><strong> 线段树（segment tree）</strong> 作为一种高级数据结构，其思想基础且简单。<br>线段树主要运用了二分思想。<br>以询问区间和为例，对于一个区间$[l, r]$，把它分成左右两段$[l, m]$和$[m + 1, r] \  (m = (l + r) &gt;&gt; 1)$，那么$\sum_{i = l}^r{a_i} = \sum_{i = l}^m{a_i} + \sum_{i = m + 1}^r{a_i}$。如果已经知道了这两个子区间的和，那么就可以求出这整个区间的和。至于如何知道这两个子区间的和，我们发现这个问题与原来的问题相当，只需要继续递归做就可以了。直到区间内只有一个元素，那么这个区间的和就是这个元素的值。仔细观察，我们如果把每个区间看做一个点，那么每个点最多有两个子节点，这是一棵二叉树，而且树的深度为$O(log_{2}n)$。且这不一棵是满二叉树，假设它是满二叉树，根据二叉树的性质，深度为$O(log_{2}n)$的满二叉树的节点数是$O(n)$的，所以线段树的节点数也是$O(n)$的。</p>
<p><br><br></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title=" 基本操作 "></a><strong> 基本操作 </strong></h3><h4 id="存储"><a href="#存储" class="headerlink" title=" 存储 "></a><strong> 存储 </strong></h4><p>线段树的存储有多种实现方法。</p>
<h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p>对于每个节点，要记录它的所代表的区间的左端点和右端点，以及这个区间的信息。</p>
<pre><code class="lang-cpp">struct Segment_Tree_Node {
    Segment_Tree_Node(int l = 0, int r = 0) : l(l), r(r) {
        x = Info();
        return;
    }
    int l, r;
    Info x;
};
</code></pre>
<p>当前点是$k$，那么它的左子节点（如果有）就是$k &lt;&lt; 1$，它的右子节点（如果有）就是$k &lt;&lt; 1 | 1$，它的父亲节点（如果有）就是$k &gt;&gt; 1$。可以证明用到节点的最大编号是小于或等于$4 \times n$的。具体证明，待填坑。。。</p>
<h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><pre><code class="lang-cpp">struct Segment_Tree_Node {
    Segment_Tree_Node(int l = 0, int r = 0) : l(l), r(r) {
        lc = rc = NULL;
        x = Info();
        return;
    }
    int l, r;
    Segment_Tree_Node *lc, *rc;
    Info x;
};
</code></pre>
<p>指针有两种实现方法：</p>
<ul>
<li>内存动态分配，动态释放。</li>
<li>先开一个内存池，往后用到不断分配，也可以用数组模拟。</li>
</ul>
<p>线段树一共有$2 \times n$个节点，每个节点除了用完全二叉树存储的要记录的以外，还要记录它左右子节点的指针。</p>
<h5 id="动态开点"><a href="#动态开点" class="headerlink" title="动态开点"></a>动态开点</h5><p>对于一个修改或询问，与它有关的节点数为$O(log_{2}n)$，所以不用把所有的节点都开出来，一个节点只有被用到时才会开。空间复杂度一般为$O(mlog_{2}n)$，所以当$n$到达$10^9$或更大时也能做。</p>
<p>后文中未明确说明，一般用完全二叉树结构存储。</p>
<p><br><br></p>
<h4 id="单点修改-amp-amp-区间查询"><a href="#单点修改-amp-amp-区间查询" class="headerlink" title=" 单点修改 &amp;&amp; 区间查询 "></a><strong> 单点修改 &amp;&amp; 区间查询 </strong></h4><blockquote>
<p>每次有两种操作：1. 把一个元素加上一个数；2. 询问区间和。</p>
</blockquote>
<p><a href="https://www.luogu.org/problemnew/show/3374" target="_blank" rel="external">模板题目链接</a></p>
<h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>记录下当前节点的所代表的区间的左端点和右端点，以及这个区间的信息（像这个例子，询问区间和就记录这个节点所代表的区间的和）。<br>若某个节点所代表的区间只有一个元素，那么这个区间的信息就由该元素算出。否则，它就有左右子节点，递归算出它们的信息，该节点的信息就由它们算出。<br>到这里预处理就结束了。</p>
<pre><code class="lang-cpp">#define lc k &lt;&lt; 1
#define rc k &lt;&lt; 1 | 1

const int N = 100010;

int n;
int a[N];

struct Node {
    int l, r, sum;
} p[N &lt;&lt; 2];

void Build(int k, int l, int r) {
    p[k].l = l;
    p[k].r = r;
    if (l == r) {
        p[k].sum = a[l];
        return;
    }
    int m = (l + r) &gt;&gt; 1;
    Build(lc, l, m);
    Build(rc, m + 1, r);
    p[k].sum = p[lc].sum + p[rc].sum;
    return;
}
</code></pre>
<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>在当前节点所代表的区间修改在$x$位置上的元素加上$d$。<br>若当前节点是叶子节点，那么该节点肯定是$x$，把该节点的信息对$d$修改。<br>否则，若它在当前节点左子节点所代表的区间内，递归修改左子节点，否则递归修改右子节点，修改完后更新当前节点的信息。<br>由于线段树的深度为$O(log_{2}n)$，所以从根节点到某叶子节点的距离为$O(log_{2}n)$，所以时间复杂度为$O(log_{2}n)$。</p>
<pre><code class="lang-cpp">void Modify(int k, int x, int d) {
    if (p[k].l == x &amp;&amp; x == p[k].r) {
        p[k].sum += d;
        return;
    }
    if (x &lt;= p[lc].r) Modify(lc, x, d);
    else Modify(rc, x, d);
    p[k].sum = p[lc].sum + p[rc].sum;
    return;
}
</code></pre>
<h5 id="询问"><a href="#询问" class="headerlink" title="询问"></a>询问</h5><p>在当前节点所代表的区间内询问在区间$[l, r]$中的元素的和。<br>若当前节点所代表的区间是区间$[l, r]$的一个子区间，那么直接返回当前节点所记录的和。<br>否则若区间$[l, r]$与当前节点左子节点所代表的区间有交集，那么答案加上递归询问左子节点的和，若区间$[l, r]$与当前节点右子节点所代表的区间有交集，那么答案加上递归询问右子节点的和。最后的总和就是答案。<br>一个区间最多被划分成线段树上的$O(log_{2}n)$个节点，所以单次询问的时间复杂度为$O(log_{2}n)$。具体证明，待填坑。。。</p>
<pre><code class="lang-cpp">int Query(int k, int l, int r) {
    if (l &lt;= p[k].l &amp;&amp; p[k].r &lt;= r) return p[k].sum;
    int sum = 0;
    if (l &lt;= p[lc].r) sum += Query(lc, l, r);
    if (p[rc].l &lt;= r) sum += Query(rc, l, r);
    return sum;
}
</code></pre>
<p>以下是主程序：</p>
<pre><code class="lang-cpp">int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, &amp;a[i]);
    Build(1, 1, n);
    while (m--) {
        int t;
        scanf(&quot;%d&quot;, &amp;t);
        if (t == 1) {
            int x, d;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;d);
            Modify(1, x, d);
        } else {
            int l, r;
            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
            printf(&quot;%d\n&quot;, Query(1, l, r));
        }
    }
    return 0;
}
</code></pre>
<p><br><br></p>
<h4 id="区间修改-amp-amp-单点查询"><a href="#区间修改-amp-amp-单点查询" class="headerlink" title=" 区间修改 &amp;&amp; 单点查询 "></a><strong> 区间修改 &amp;&amp; 单点查询 </strong></h4><blockquote>
<p>每次有两种操作：1. 把一个区间加上一个数；2. 询问一个元素的和。</p>
</blockquote>
<p><a href="https://www.luogu.org/problemnew/show/3368" target="_blank" rel="external">模板题目链接</a></p>
<p>这种被介绍在树状数组中或许更好一点。<br>把原序列$a$差分成序列$b$，对于每一个修改操作$(l, r, x)$，把它转成两个操作，在差分数组的第$l$个元素上加上$x$，在差分数组的第$r + 1$个元素上加上$-x$。这样，如果要求原序列第$x$个元素的值，那么就是差分数组的前$x$个元素的和$\sum_{i = 1}^x{b_i}$。这样就把(区间修改 &amp;&amp; 单点查询)转化成(单点修改 &amp;&amp; 区间查询)了。</p>
<p>以下是主程序：</p>
<pre><code class="lang-cpp">int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i) {
        scanf(&quot;%d&quot;, &amp;b[i]);
        a[i] = b[i] - b[i - 1];
    }
    Build(1, 1, n);
    while (m--) {
        int t;
        scanf(&quot;%d&quot;, &amp;t);
        if (t == 1) {
            int l, r, d;
            scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d);
            Modify(1, l, d);
            if (r &lt; n) Modify(1, r + 1, -d);
        } else {
            int x;
            scanf(&quot;%d&quot;, &amp;x);
            printf(&quot;%d\n&quot;, Query(1, 1, x));
        }
    }
    return 0;
}
</code></pre>
<p><br><br></p>
<h4 id="区间修改-amp-amp-区间查询"><a href="#区间修改-amp-amp-区间查询" class="headerlink" title=" 区间修改 &amp;&amp; 区间查询 "></a><strong> 区间修改 &amp;&amp; 区间查询 </strong></h4><blockquote>
<p>每次有两种操作：1. 把一个区间加上一个数；2. 询问区间和。</p>
</blockquote>
<p><a href="https://www.luogu.org/problemnew/show/3372" target="_blank" rel="external">模板题目链接</a></p>
<p>这里介绍一种 <strong> Lazy-Tag </strong> 思想。<br>在每个节点记录一个标记$lazy$，代表这个区间还没有下传的标记。例如，在区间加一个数中，记录的就是这个区间的所有子区间还要加的数的总和。</p>
<h5 id="预处理-1"><a href="#预处理-1" class="headerlink" title="预处理"></a>预处理</h5><p>增加对每个节点$lazy$标记的预处理。</p>
<pre><code class="lang-cpp">#define lc k &lt;&lt; 1
#define rc k &lt;&lt; 1 | 1

typedef long long LL;

const int N = 100010;

int n;
LL a[N];

struct Node {
    int l, r;
    LL sum, lazy;
} p[N &lt;&lt; 2];

void Build(int k, int l, int r) {
    p[k].l = l;
    p[k].r = r;
    if (l == r) {
        p[k].sum = a[l];
        p[k].lazy = 0;
        return;
    }
    int m = (l + r) &gt;&gt; 1;
    Build(lc, l, m);
    Build(rc, m + 1, r);
    p[k].sum = p[lc].sum + p[rc].sum;
    return;
}
</code></pre>
<h5 id="标记下传"><a href="#标记下传" class="headerlink" title="标记下传"></a>标记下传</h5><p>把节点$k$的标记下传。<br>左子节点的和加上左子节点所代表的区间所含的元素个数$\times$当前节点的标记。左子节点的标记加上当前节点的标记。<br>右子节点的和加上右子节点所代表的区间所含的元素个数$\times$当前节点的标记。右子节点的标记加上当前节点的标记。<br>不要忘了把当前节点的标记清零。</p>
<pre><code class="lang-cpp">inline void Pushdown(int k) {
    p[lc].sum += p[k].lazy * (p[lc].r - p[lc].l + 1);
    p[lc].lazy += p[k].lazy;
    p[rc].sum += p[k].lazy * (p[rc].r - p[rc].l + 1);
    p[rc].lazy += p[k].lazy;
    p[k].lazy = 0;
    return;
}
</code></pre>
<h5 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h5><p>在当前节点所代表的区间内将在区间$[l, r]$中的元素的加上$d$。<br>若当前节点所代表的区间是区间$[l, r]$的一个子区间，那么当前节点的和加上$d \times$当前区间的元素个数，$lazy$标记加上$d$。<br>否则下传当前节点的标记。若区间$[l, r]$与当前节点左子节点所代表的区间有交集，那么对左子节点进行修改，若区间$[l, r]$与当前节点右子节点所代表的区间有交集，那么对右子节点进行修改，修改完后更新当前节点的信息。</p>
<pre><code class="lang-cpp">void Modify(int k, int l, int r, LL d) {
    if (l &lt;= p[k].l &amp;&amp; p[k].r &lt;= r) {
        p[k].sum += d * (p[k].r - p[k].l + 1);
        p[k].lazy += d;
        return;
    }
    if (p[k].lazy) Pushdown(k);
    if (l &lt;= p[lc].r) Modify(lc, l, r, d);
    if (p[rc].l &lt;= r) Modify(rc, l, r, d);
    p[k].sum = p[lc].sum + p[rc].sum;
    return;
}
</code></pre>
<h5 id="询问-1"><a href="#询问-1" class="headerlink" title="询问"></a>询问</h5><p>在当前节点所代表的区间内询问在区间$[l, r]$中的元素的和。<br>若当前节点所代表的区间是区间$[l, r]$的一个子区间，那么直接返回当前节点所记录的和。<br>否则下传当前节点的标记。若区间$[l, r]$与当前节点左子节点所代表的区间有交集，那么答案加上递归询问左子节点的和，若区间$[l, r]$与当前节点右子节点所代表的区间有交集，那么答案加上递归询问右子节点的和。最后的总和就是答案。</p>
<pre><code class="lang-cpp">LL Query(int k, int l, int r) {
    if (l &lt;= p[k].l &amp;&amp; p[k].r &lt;= r) return p[k].sum;
    if (p[k].lazy) Pushdown(k);
    LL sum = 0;
    if (l &lt;= p[lc].r) sum += Query(lc, l, r);
    if (p[rc].l &lt;= r) sum += Query(rc, l, r);
    return sum;
}
</code></pre>
<p>以下是主程序：</p>
<pre><code class="lang-cpp">int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%lld&quot;, &amp;a[i]);
    Build(1, 1, n);
    while (m--) {
        int t, l, r;
        scanf(&quot;%d%d%d&quot;, &amp;t, &amp;l, &amp;r);
        if (t == 1) {
            LL d;
            scanf(&quot;%lld&quot;, &amp;d);
            Modify(1, l, r, d);
        } else printf(&quot;%lld\n&quot;, Query(1, l, r));
    }
    return 0;
}
</code></pre>
<p>$Pushdown$是$O(1)$的，所以$lazy-tag$并不会影响复杂度。</p>
<p><br>&lt;/br&gt;<br><br><br></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title=" 扩展 "></a><strong> 扩展 </strong></h3><h4 id="可持久化线段树和主席树（函数式线段树）"><a href="#可持久化线段树和主席树（函数式线段树）" class="headerlink" title=" 可持久化线段树和主席树（函数式线段树） "></a><strong> 可持久化线段树和主席树（函数式线段树） </strong></h4><p><strong> 可持久化线段树 </strong> 就是线段树的可持久化。它有一个最初的版本，每次可在在某个版本的基础上修改并新增一个版本，且需要支持查询历史版本。</p>
<p>如果每次复制原来的线段树，再在新的线段树上修改，时间和空间复杂度都会到达$O(n \times m)$。这样高的复杂度是无法承受的。<br>我们观察后发现，线段树每次修改，只会修改线段树上$O(log_{2}n)$个节点，我们只需要新建这$O(log_{2}n)$个节点，其它的节点我们可以共用。这里就要用到动态开点了。这样时间复杂度和空间复杂度都降为$O((n + m)log_{2}n)$。</p>
<p><a href="http://cogs.pro:8080/cogs/problem/problem.php?pid=2554" target="_blank" rel="external">模板题目链接</a></p>
<h5 id="预处理-2"><a href="#预处理-2" class="headerlink" title="预处理"></a>预处理</h5><p>现在是动态开点的，所以要开一个节点的内存池。节点信息中要加上左右子节点的指针（可以用数组模拟）。</p>
<pre><code class="lang-cpp">const int N = 100010, M = 100010, P = 17, _INF = 0x80000000;

int n, m;
int a[N];

int tot = 0, root[M];
struct Node {
    int lc, rc, l, r, Max;
} p[(N &lt;&lt; 2) + M * P];

int Build(int l, int r) {
    int k = ++tot;
    p[k].l = l;
    p[k].r = r;
    if (l == r) {
        p[k].Max = a[l];
        return k;
    }
    int m = (l + r) &gt;&gt; 1;
    p[k].lc = Build(l, m);
    p[k].rc = Build(m + 1, r);
    p[k].Max = max(p[p[k].lc].Max, p[p[k].rc].Max);
    return k;
}
</code></pre>
<h5 id="修改-2"><a href="#修改-2" class="headerlink" title="修改"></a>修改</h5><p>对于所有要修改的节点，再新建一个（从内存池中分配一个），对其进行修改。</p>
<pre><code class="lang-cpp">int Modify(int k, int x, int d) {
    int K = ++tot;
    p[K] = p[k];
    if (p[k].l == x &amp;&amp; x == p[k].r) {
        p[K].Max = d;
        return K;
    }
    if (x &lt;= p[p[k].lc].r) p[K].lc = Modify(p[k].lc, x, d);
    else p[K].rc = Modify(p[k].rc, x, d);
    p[K].Max = max(p[p[K].lc].Max, p[p[K].rc].Max);
    return K;
}
</code></pre>
<h5 id="询问-2"><a href="#询问-2" class="headerlink" title="询问"></a>询问</h5><p>询问其实变化不大。</p>
<pre><code class="lang-cpp">int Query(int k, int l, int r) {
    if (l &lt;= p[k].l &amp;&amp; p[k].r &lt;= r) return p[k].Max;
    int Max = _INF;
    if (l &lt;= p[p[k].lc].r) Max = max(Max, Query(p[k].lc, l, r));
    if (p[p[k].rc].l &lt;= r) Max = max(Max, Query(p[k].rc, l, r));
    return Max;
}
</code></pre>
<p>以下是主程序：</p>
<pre><code class="lang-cpp">int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, &amp;a[i]);
    int cnt = 0;
    root[cnt = 1] = Build(1, n);
    while (m--) {
        int t;
        scanf(&quot;%d&quot;, &amp;t);
        if (!t) {
            int k, l, r;
            scanf(&quot;%d%d%d&quot;, &amp;k, &amp;l, &amp;r);
            printf(&quot;%d\n&quot;, Query(root[k], l, r));
        } else {
            int k, x, d;
            scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;d);
            root[++cnt] = Modify(root[k], x, d);
        }
    }
    return 0;
}
</code></pre>
<p><br><br></p>
<h4 id="线段树合并"><a href="#线段树合并" class="headerlink" title=" 线段树合并 "></a><strong> 线段树合并 </strong></h4><p>将两棵线段树合并成一棵新的线段树。</p>
<pre><code class="lang-cpp">int Merge(int k1, int k2) {
    if (!k1) return k2;
    if (!k2) return k1;
    int k = ++tot;
    p[k].lc = Merge(p[k1].lc, p[k2].lc);
    p[k].rc = Merge(p[k1].rc, p[k2].rc);
    p[k].sum = p[p[k].lc].sum + p[p[k].rc].sum;
    return k;
}
</code></pre>
<p>开始时你有$n$棵线段树，每棵线段树都有一个节点，现在你不断把它们合并，直到只有一棵线段树，这个总的时间复杂度是$O(nlog_{2}n)$的。因为你每次合并都会使某些区间上所含的点变多，那么总复杂度即为线段树上所有节点所包含的元素数之和，线段树一共有$O(log_{2}n)$层，每层都有$O(n)$个节点，所以一共有$O(nlog_{2}n)$个节点，所以时间复杂度也是这个。</p>
<h4 id="线段树分裂"><a href="#线段树分裂" class="headerlink" title=" 线段树分裂 "></a><strong> 线段树分裂 </strong></h4>]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CodeForces555E]]></title>
      <url>/2017/10/22/CodeForces555E/</url>
      <content type="html"><![CDATA[<h1 id="Case-of-Computer-Network"><a href="#Case-of-Computer-Network" class="headerlink" title="Case of Computer Network"></a><a href="http://codeforces.com/contest/555/problem/E" target="_blank" rel="external">Case of Computer Network</a></h1><p><center> time limit per test3 seconds</center></p>
<p><center> memory limit per test256 megabytes</center></p>
<p><center> inputstandard input</center></p>
<p><center> outputstandard output</center></p>
<h2 id="Description"><a href="#Description" class="headerlink" title=" Description "></a><strong> Description </strong></h2><blockquote>
<p>Andrewid the Android is a galaxy-known detective. Now he is preparing a defense against a possible attack by hackers on a major computer network.</p>
<p>In this network are $n$ vertices, some pairs of vertices are connected by $m$ undirected channels. It is planned to transfer $q$ important messages via this network, the i-th of which must be sent from vertex $s_i$ to vertex $d_i$ via one or more channels, perhaps through some intermediate vertices.</p>
<p>To protect against attacks a special algorithm was developed. Unfortunately it can be applied only to the network containing directed channels. Therefore, as new channels can’t be created, it was decided for each of the existing undirected channels to enable them to transmit data only in one of the two directions.</p>
<p>Your task is to determine whether it is possible so to choose the direction for each channel so that each of the $q$ messages could be successfully transmitted.</p>
</blockquote>
<h2 id="Input"><a href="#Input" class="headerlink" title=" Input "></a><strong> Input </strong></h2><blockquote>
<p>The first line contains three integers $n$, $m$ and $q$ ($1 \le n,m,q \le 2 \times 10^5$) — the number of nodes, channels and important messages.</p>
<p>Next $m$ lines contain two integers each, $v_i$ and $u_i$ ($1 \le v_i,u_i \le n, \  v_i \neq u_i$), that means that between nodes $v_i$ and $u_i$ is a channel. Between a pair of nodes can exist more than one channel.</p>
<p>Next $q$ lines contain two integers $s_i$ and $d_i$ ($1 \le s_i, \le  d_i \le n, \  s_i \neq d_i$) — the numbers of the nodes of the source and destination of the corresponding message.</p>
<p>It is not guaranteed that in it initially possible to transmit all the messages.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title=" Output "></a><strong> Output </strong></h2><blockquote>
<p>If a solution exists, print on a single line “Yes” (without the quotes). Otherwise, print “No” (without the quotes).</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title=" Examples "></a><strong> Examples </strong></h2><h3 id="input"><a href="#input" class="headerlink" title=" input "></a><strong> input </strong></h3><blockquote>
<p>4 4 2<br>1 2<br>1 3<br>2 3<br>3 4<br>1 3<br>4 2</p>
</blockquote>
<h3 id="output"><a href="#output" class="headerlink" title=" output "></a><strong> output </strong></h3><blockquote>
<p>Yes</p>
</blockquote>
<h3 id="input-1"><a href="#input-1" class="headerlink" title=" input "></a><strong> input </strong></h3><blockquote>
<p>3 2 2<br>1 2<br>3 2<br>1 3<br>2 1</p>
</blockquote>
<h3 id="output-1"><a href="#output-1" class="headerlink" title=" output "></a><strong> output </strong></h3><blockquote>
<p>No</p>
</blockquote>
<h3 id="input-2"><a href="#input-2" class="headerlink" title=" input "></a><strong> input </strong></h3><blockquote>
<p>3 3 2<br>1 2<br>1 2<br>3 2<br>1 3<br>2 1</p>
</blockquote>
<h3 id="output-2"><a href="#output-2" class="headerlink" title=" output "></a><strong> output </strong></h3><blockquote>
<p>Yes</p>
</blockquote>
<h2 id="Note"><a href="#Note" class="headerlink" title=" Note "></a><strong> Note </strong></h2><blockquote>
<p>In the first sample test you can assign directions, for example, as follows: 1 → 2, 1 → 3, 3 → 2, 4 → 3. Then the path for for the first message will be 1 → 3, and for the second one — 4 → 3 → 2.</p>
<p>In the third sample test you can assign directions, for example, as follows: 1 → 2, 2 → 1, 2 → 3. Then the path for the first message will be 1 → 2 → 3, and for the second one — 2 → 1.</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title=" Solution "></a><strong> Solution </strong></h2><blockquote>
<p>给出一个$n$个点，$m$条边的无向图，问是否存在一种给每条边定向把它转成有向图的方法，使$q$个点对$s_i,d_i$，$s_i$可以到达$d_i$。可以输出”Yes”（不带引号），不可以输出”No”（不带引号）。</p>
<p>对于一个点对$s_i,d_i$，$s_i$到$d_i$所有路径的边集一定是一些由割边连接着的边双，割边必须要强制定向。至于边双，发现每个边双一定可以给它定向使它强连通，该强连通子图任意两个点都可以互相到达，所以只需要处理割边上的冲突。把原图的每个边双缩点，使原图成为一个森林（原图可能不联通）。再对进行树上差分，算出每条边的两种方向的个数。若某个点对$s_i,d_i$不在同一个联通块内，则不存在方案。否则算出两个点的LCA$l_i$，对$u_i$到$l_i$打上向上边的标记，对$l_i$到$v_i$打上向下边的标记。最后DFS一遍算出每条边的两种方向的个数，枚举每条边，若某条边两种方向存在冲突，则不存在方案，否则存在方案。</p>
</blockquote>
<h2 id="Standrad"><a href="#Standrad" class="headerlink" title=" Standrad "></a><strong> Standrad </strong></h2><pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

const int N = 200010, M = 200010, P = 18;

int n, m, q;
struct Graph {
    int tot, head[N];
    Graph() {
        tot = -1;
        memset(head, -1, sizeof(head));
        return;
    }
    struct Edge {
        int p, next;
    } edge[M &lt;&lt; 1];
    inline void Add(int u, int v) {
        edge[++tot] = (Edge) {v, head[u]};
        head[u] = tot;
        return;
    }
} og, ng;

int f[N], link[N];
int Gf(int k) {
    return (f[k] != k) ? (f[k] = Gf(f[k])) : (k);
}
int Link_Gf(int k) {
    return (link[k] != k) ? (link[k] = Link_Gf(link[k])) : (k);
}

int k = 0, dfn[N], low[N], fa[N][P], dep[N];
int tk = 0, t[N];

void Tarjan(int u, int comedge) {
    dfn[u] = low[u] = ++k;
    t[++tk] = u;
    for (int i = og.head[u]; ~i; i = og.edge[i].next) {
        int v = og.edge[i].p;
        if (!dfn[v]) {
            Tarjan(v, i);
            low[u] = min(low[u], low[v]);
        } else if ((i ^ 1) != comedge) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        if (~comedge) fa[u][0] = og.edge[comedge ^ 1].p;
        for (int i; i = t[tk--], i != u; f[i] = u);
    }
    return;
}

void DFS(int u) {
    dep[u] = dep[fa[u][0]] + 1;
    for (int i = ng.head[u]; ~i; i = ng.edge[i].next)
        DFS(ng.edge[i].p);
    return;
}

void Pre() {
    for (int j = 1; j &lt; P; ++j)
        for (int i = 1; i &lt;= n; ++i)
            fa[i][j] = fa[fa[i][j - 1]][j - 1];
    return;
}

int LCA(int u, int v) {
    if (dep[u] &lt; dep[v]) swap(u, v);
    for (int i = 0, j = dep[u] - dep[v]; j; ++i, j &gt;&gt;= 1)
        if (j &amp; 1) u = fa[u][i];
    if (u == v) return u;
    for (int i = P - 1; ~i; --i)
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    return fa[u][0];
}

int sum1[N], sum2[N];

void Count(int u) {
    for (int i = ng.head[u]; ~i; i = ng.edge[i].next) {
        int v = ng.edge[i].p;
        Count(v);
        sum1[u] += sum1[v];
        sum2[u] += sum2[v];
    }
    return;
}

int main() {
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);
    for (int i = 1; i &lt;= n; ++i) {
        f[i] = i;
        link[i] = i;
    }
    for (int i = 1; i &lt;= m; ++i) {
        int u, v;
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        og.Add(u, v);
        og.Add(v, u);
        link[Link_Gf(v)] = Link_Gf(u);
    }
    for (int i = 1; i &lt;= n; ++i)
        if (link[i] == i) Tarjan(i, -1);
    for (int i = 1; i &lt;= n; ++i)
        if (fa[i][0]) ng.Add(fa[i][0] = Gf(fa[i][0]), i);
    for (int i = 1; i &lt;= n; ++i)
        if (link[i] == i) DFS(i);
    Pre();
    for (int i = 1; i &lt;= q; ++i) {
        int u, v;
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        if (Link_Gf(u) != Link_Gf(v)) {
            puts(&quot;No&quot;);
            return 0;
        }
        u = Gf(u);
        v = Gf(v);
        int l = LCA(u, v);
        ++sum1[u];
        --sum1[l];
        ++sum2[v];
        --sum2[l];
    }
    for (int i = 1; i &lt;= n; ++i)
        if (link[i] == i) Count(i);
    bool flag = 1;
    for (int i = 1; i &lt;= n; ++i)
        if (sum1[i] &amp;&amp; sum2[i]) {
            flag = 0;
            break;
        }
    if (flag) puts(&quot;Yes&quot;);
    else puts(&quot;No&quot;);
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> CodeForces </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 边双连通分量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BZOJ题目列表]]></title>
      <url>/2017/10/18/BZOJ%E9%A2%98%E7%9B%AE%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h3 id="学习一天可做"><a href="#学习一天可做" class="headerlink" title="学习一天可做"></a>学习一天可做</h3><div class="table-container">
<table>
<thead>
<tr>
<th>题号</th>
<th>算法</th>
<th>思想难度</th>
<th>实现难度</th>
<th>总难度</th>
<th>推荐指数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1214</td>
<td>Ruby</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>3816</td>
<td>Ruby</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>1000</td>
<td>可持久化动态仙人掌剖分</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>10</td>
</tr>
<tr>
<td>2462</td>
<td>输出10个1</td>
<td>6</td>
<td>3</td>
<td>9</td>
<td>1</td>
</tr>
<tr>
<td>2463</td>
<td>小学奥数</td>
<td>10</td>
<td>2</td>
<td>12</td>
<td>2</td>
</tr>
<tr>
<td>1192</td>
<td>找规律/二分图</td>
<td>9</td>
<td>5</td>
<td>14</td>
<td>9</td>
</tr>
</tbody>
</table>
</div>
<p><br><br></p>
<h3 id="普及组难度"><a href="#普及组难度" class="headerlink" title="普及组难度"></a>普及组难度</h3><div class="table-container">
<table>
<thead>
<tr>
<th>题号</th>
<th>算法</th>
<th>思想难度</th>
<th>实现难度</th>
<th>总难度</th>
<th>推荐指数</th>
</tr>
</thead>
<tbody>
<tr>
<td>2659</td>
<td>数学</td>
<td>20</td>
<td>7</td>
<td>27</td>
<td>2</td>
</tr>
<tr>
<td>1968</td>
<td>枚举</td>
<td>15</td>
<td>13</td>
<td>28</td>
<td>2</td>
</tr>
<tr>
<td>2761</td>
<td>去重</td>
<td>12</td>
<td>18</td>
<td>30</td>
<td>6</td>
</tr>
<tr>
<td>3767</td>
<td>高精度A+B</td>
<td>10</td>
<td>20</td>
<td>30</td>
<td>2</td>
</tr>
<tr>
<td>1432</td>
<td>找规律</td>
<td>27</td>
<td>5</td>
<td>32</td>
<td>3</td>
</tr>
<tr>
<td>3098</td>
<td>随机卡HASH</td>
<td>23</td>
<td>10</td>
<td>33</td>
<td>2</td>
</tr>
<tr>
<td>1800</td>
<td>统计</td>
<td>20</td>
<td>16</td>
<td>36</td>
<td>3</td>
</tr>
<tr>
<td>1218</td>
<td>枚举</td>
<td>20</td>
<td>17</td>
<td>37</td>
<td>2</td>
</tr>
<tr>
<td>4001</td>
<td>找规律</td>
<td>28</td>
<td>9</td>
<td>37</td>
<td>3</td>
</tr>
<tr>
<td>2760</td>
<td>字符串处理</td>
<td>12</td>
<td>26</td>
<td>38</td>
<td>1</td>
</tr>
<tr>
<td>1088</td>
<td>DP/判断</td>
<td>22</td>
<td>17</td>
<td>39</td>
<td>6</td>
</tr>
<tr>
<td>1034</td>
<td>贪心</td>
<td>24</td>
<td>16</td>
<td>40</td>
<td>6</td>
</tr>
<tr>
<td>1207</td>
<td>DP</td>
<td>23</td>
<td>17</td>
<td>40</td>
<td>2</td>
</tr>
<tr>
<td>2748</td>
<td>DP</td>
<td>21</td>
<td>19</td>
<td>40</td>
<td>4</td>
</tr>
<tr>
<td>4302</td>
<td>分类讨论</td>
<td>29</td>
<td>11</td>
<td>40</td>
<td></td>
</tr>
<tr>
<td>1083</td>
<td>最小生成树</td>
<td>17</td>
<td>25</td>
<td>42</td>
<td>9</td>
</tr>
<tr>
<td>2563</td>
<td>转换后排序</td>
<td>27</td>
<td>15</td>
<td>42</td>
<td>7</td>
</tr>
<tr>
<td>3097</td>
<td>构造卡HASH</td>
<td>27</td>
<td>15</td>
<td>42</td>
<td>2</td>
</tr>
<tr>
<td>1022</td>
<td>简单博弈</td>
<td>30</td>
<td>13</td>
<td>43</td>
<td>3</td>
</tr>
<tr>
<td>2465</td>
<td>贪心</td>
<td>25</td>
<td>20</td>
<td>45</td>
<td>4</td>
</tr>
<tr>
<td>2122</td>
<td>暴力</td>
<td>28</td>
<td>18</td>
<td>46</td>
<td>2</td>
</tr>
<tr>
<td>1197</td>
<td>DP</td>
<td>31</td>
<td>19</td>
<td>50</td>
<td>2</td>
</tr>
<tr>
<td>1295</td>
<td>搜索</td>
<td>20</td>
<td>30</td>
<td>50</td>
<td>5</td>
</tr>
<tr>
<td>1821</td>
<td>最小生成树</td>
<td>25</td>
<td>25</td>
<td>50</td>
<td>4</td>
</tr>
<tr>
<td>2134</td>
<td>期望DP</td>
<td>30</td>
<td>20</td>
<td>50</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<p><br><br></p>
<h3 id="提高组难度"><a href="#提高组难度" class="headerlink" title="提高组难度"></a>提高组难度</h3><div class="table-container">
<table>
<thead>
<tr>
<th>题号</th>
<th>算法</th>
<th>思想难度</th>
<th>实现难度</th>
<th>总难度</th>
<th>推荐指数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1876</td>
<td>高精求GCD</td>
<td>18</td>
<td>33</td>
<td>51</td>
<td>2</td>
</tr>
<tr>
<td>2173</td>
<td>找规律</td>
<td>37</td>
<td>14</td>
<td>51</td>
<td>3</td>
</tr>
<tr>
<td>2208</td>
<td>暴力</td>
<td>23</td>
<td>28</td>
<td>51</td>
<td>2</td>
</tr>
<tr>
<td>1258</td>
<td>找规律</td>
<td>33</td>
<td>19</td>
<td>52</td>
<td>2</td>
</tr>
<tr>
<td>2005</td>
<td>数学</td>
<td>30</td>
<td>22</td>
<td>52</td>
<td>6</td>
</tr>
<tr>
<td>2429</td>
<td>最小生成树</td>
<td>23</td>
<td>29</td>
<td>52</td>
<td>3</td>
</tr>
<tr>
<td>2464</td>
<td>最短路</td>
<td>21</td>
<td>31</td>
<td>52</td>
<td>2</td>
</tr>
<tr>
<td>1028</td>
<td>枚举</td>
<td>26</td>
<td>27</td>
<td>53</td>
<td>4</td>
</tr>
<tr>
<td>2222</td>
<td>打表+手算</td>
<td>39</td>
<td>14</td>
<td>53</td>
<td>1</td>
</tr>
<tr>
<td>2456</td>
<td>脑补</td>
<td>34</td>
<td>19</td>
<td>53</td>
<td>6</td>
</tr>
<tr>
<td>4300</td>
<td>DP+单调转移</td>
<td>30</td>
<td>23</td>
<td>53</td>
<td></td>
</tr>
<tr>
<td>1008</td>
<td>数学分析+快速幂</td>
<td>27</td>
<td>27</td>
<td>54</td>
<td>7</td>
</tr>
<tr>
<td>1413</td>
<td>博弈</td>
<td>39</td>
<td>15</td>
<td>54</td>
<td>4</td>
</tr>
<tr>
<td>4368</td>
<td>贪心</td>
<td>31</td>
<td>23</td>
<td>54</td>
<td></td>
</tr>
<tr>
<td>1012</td>
<td>树状数组/线段树/RMQ</td>
<td>24</td>
<td>31</td>
<td>55</td>
<td>3</td>
</tr>
<tr>
<td>1228</td>
<td>博弈论SG函数</td>
<td>40</td>
<td>15</td>
<td>55</td>
<td>3</td>
</tr>
<tr>
<td>1489</td>
<td>DP</td>
<td>32</td>
<td>23</td>
<td>55</td>
<td>5</td>
</tr>
<tr>
<td>1607</td>
<td>线性筛因数</td>
<td>27</td>
<td>28</td>
<td>55</td>
<td>6</td>
</tr>
<tr>
<td>1050</td>
<td>并查集</td>
<td>27</td>
<td>29</td>
<td>56</td>
<td>8</td>
</tr>
<tr>
<td>1053</td>
<td>搜索</td>
<td>27</td>
<td>29</td>
<td>56</td>
<td>4</td>
</tr>
<tr>
<td>1261</td>
<td>DP</td>
<td>31</td>
<td>25</td>
<td>56</td>
<td>6</td>
</tr>
<tr>
<td>1303</td>
<td>前缀和</td>
<td>33</td>
<td>23</td>
<td>56</td>
<td>8</td>
</tr>
<tr>
<td>1569</td>
<td>DP</td>
<td>28</td>
<td>28</td>
<td>56</td>
<td>4</td>
</tr>
<tr>
<td>1970</td>
<td>暴力+高精</td>
<td>25</td>
<td>31</td>
<td>56</td>
<td>1</td>
</tr>
<tr>
<td>2241</td>
<td>暴力</td>
<td>28</td>
<td>28</td>
<td>56</td>
<td>2</td>
</tr>
<tr>
<td>1002</td>
<td>递推+高精度</td>
<td>32</td>
<td>25</td>
<td>57</td>
<td>2</td>
</tr>
<tr>
<td>1024</td>
<td>搜索</td>
<td>29</td>
<td>28</td>
<td>57</td>
<td>4</td>
</tr>
<tr>
<td>1054</td>
<td>BFS</td>
<td>27</td>
<td>30</td>
<td>57</td>
<td>5</td>
</tr>
<tr>
<td>1059</td>
<td>二分图</td>
<td>27</td>
<td>30</td>
<td>57</td>
<td>9</td>
</tr>
<tr>
<td>1191</td>
<td>二分图</td>
<td>27</td>
<td>30</td>
<td>57</td>
<td>9</td>
</tr>
<tr>
<td>1260</td>
<td>DP</td>
<td>32</td>
<td>25</td>
<td>57</td>
<td>6</td>
</tr>
<tr>
<td>1263</td>
<td>贪心+高精度</td>
<td>29</td>
<td>28</td>
<td>57</td>
<td>5</td>
</tr>
<tr>
<td>1816</td>
<td>二分</td>
<td>31</td>
<td>26</td>
<td>57</td>
<td>6</td>
</tr>
<tr>
<td>1854</td>
<td>二分图</td>
<td>27</td>
<td>30</td>
<td>57</td>
<td>6</td>
</tr>
<tr>
<td>1967</td>
<td>Floodfill最短路/贪心Cheat</td>
<td>42</td>
<td>15</td>
<td>57</td>
<td>1</td>
</tr>
<tr>
<td>3505</td>
<td>数学</td>
<td>29</td>
<td>28</td>
<td>57</td>
<td>4</td>
</tr>
<tr>
<td>4247</td>
<td>背包DP</td>
<td>31</td>
<td>26</td>
<td>57</td>
<td></td>
</tr>
<tr>
<td>1206</td>
<td>堆</td>
<td>27</td>
<td>31</td>
<td>58</td>
<td>3</td>
</tr>
<tr>
<td>1296</td>
<td>DP</td>
<td>33</td>
<td>25</td>
<td>58</td>
<td>6</td>
</tr>
<tr>
<td>1485</td>
<td>卡特兰数</td>
<td>29</td>
<td>29</td>
<td>58</td>
<td>3</td>
</tr>
<tr>
<td>1856</td>
<td>卡特兰数</td>
<td>29</td>
<td>29</td>
<td>58</td>
<td>3</td>
</tr>
<tr>
<td>2457</td>
<td>贪心</td>
<td>33</td>
<td>25</td>
<td>58</td>
<td>5</td>
</tr>
<tr>
<td>2467</td>
<td>找规律</td>
<td>37</td>
<td>21</td>
<td>58</td>
<td>3</td>
</tr>
<tr>
<td>2764</td>
<td>DP+高精度</td>
<td>26</td>
<td>32</td>
<td>58</td>
<td>2</td>
</tr>
<tr>
<td>1045&amp;3293</td>
<td>数学求中位数</td>
<td>33</td>
<td>25</td>
<td>58</td>
<td>5</td>
</tr>
<tr>
<td>1013</td>
<td>高斯消元</td>
<td>28</td>
<td>31</td>
<td>59</td>
<td>4</td>
</tr>
<tr>
<td>1025</td>
<td>DP</td>
<td>32</td>
<td>27</td>
<td>59</td>
<td>5</td>
</tr>
<tr>
<td>1078</td>
<td>模拟斜堆</td>
<td>31</td>
<td>28</td>
<td>59</td>
<td>4</td>
</tr>
<tr>
<td>1265</td>
<td>高精度</td>
<td>29</td>
<td>30</td>
<td>59</td>
<td>2</td>
</tr>
<tr>
<td>1433</td>
<td>二分图</td>
<td>29</td>
<td>30</td>
<td>59</td>
<td>4</td>
</tr>
<tr>
<td>1505</td>
<td>贪心</td>
<td>35</td>
<td>24</td>
<td>59</td>
<td>5</td>
</tr>
<tr>
<td>2048</td>
<td>数学</td>
<td>39</td>
<td>20</td>
<td>59</td>
<td>3</td>
</tr>
<tr>
<td>2156</td>
<td>最短路</td>
<td>29</td>
<td>30</td>
<td>59</td>
<td>2</td>
</tr>
<tr>
<td>3108</td>
<td>乱搞</td>
<td>36</td>
<td>23</td>
<td>59</td>
<td>4</td>
</tr>
<tr>
<td>3214</td>
<td>字符串处理</td>
<td>24</td>
<td>35</td>
<td>59</td>
<td>2</td>
</tr>
<tr>
<td>3668</td>
<td>进制乱搞</td>
<td>27</td>
<td>32</td>
<td>59</td>
<td>6</td>
</tr>
<tr>
<td>4195</td>
<td>离散化+并查集</td>
<td>28</td>
<td>31</td>
<td>59</td>
<td>4</td>
</tr>
<tr>
<td>1019</td>
<td>DP</td>
<td>35</td>
<td>25</td>
<td>60</td>
<td>3</td>
</tr>
<tr>
<td>1055</td>
<td>DP</td>
<td>33</td>
<td>27</td>
<td>60</td>
<td>6</td>
</tr>
<tr>
<td>1452</td>
<td>三维树状数组</td>
<td>27</td>
<td>33</td>
<td>60</td>
<td>3</td>
</tr>
<tr>
<td>1509</td>
<td>树上最长链</td>
<td>30</td>
<td>30</td>
<td>60</td>
<td>6</td>
</tr>
<tr>
<td>1867</td>
<td>DP</td>
<td>32</td>
<td>28</td>
<td>60</td>
<td>5</td>
</tr>
<tr>
<td>1965</td>
<td>快速幂+快速乘</td>
<td>30</td>
<td>30</td>
<td>60</td>
<td>7</td>
</tr>
<tr>
<td>2435</td>
<td>BFS</td>
<td>30</td>
<td>30</td>
<td>60</td>
<td>5</td>
</tr>
<tr>
<td>2705</td>
<td>欧拉函数</td>
<td>30</td>
<td>30</td>
<td>60</td>
<td>6</td>
</tr>
<tr>
<td>2783</td>
<td>树上倍增</td>
<td>30</td>
<td>30</td>
<td>60</td>
<td>6</td>
</tr>
<tr>
<td>3210</td>
<td>坐标转化</td>
<td>33</td>
<td>27</td>
<td>60</td>
<td>5</td>
</tr>
<tr>
<td>1015</td>
<td>并查集</td>
<td>32</td>
<td>29</td>
<td>61</td>
<td>8</td>
</tr>
<tr>
<td>1036</td>
<td>树链剖分/动态树</td>
<td>26</td>
<td>35</td>
<td>61</td>
<td>10</td>
</tr>
<tr>
<td>1047</td>
<td>二维RMQ</td>
<td>27</td>
<td>34</td>
<td>61</td>
<td>5</td>
</tr>
<tr>
<td>1084</td>
<td>DP</td>
<td>33</td>
<td>28</td>
<td>61</td>
<td>7</td>
</tr>
<tr>
<td>1213</td>
<td>二分+高精</td>
<td>25</td>
<td>36</td>
<td>61</td>
<td>1</td>
</tr>
<tr>
<td>3106</td>
<td>DP</td>
<td>31</td>
<td>30</td>
<td>61</td>
<td>5</td>
</tr>
<tr>
<td>3142</td>
<td>数学</td>
<td>36</td>
<td>25</td>
<td>61</td>
<td>5</td>
</tr>
<tr>
<td>3613</td>
<td>二分+贪心</td>
<td>33</td>
<td>28</td>
<td>61</td>
<td>4</td>
</tr>
<tr>
<td>1026</td>
<td>数位DP</td>
<td>31</td>
<td>31</td>
<td>62</td>
<td>6</td>
</tr>
<tr>
<td>1079</td>
<td>记忆化搜索</td>
<td>31</td>
<td>31</td>
<td>62</td>
<td>2</td>
</tr>
<tr>
<td>1081</td>
<td>模拟</td>
<td>32</td>
<td>30</td>
<td>62</td>
<td>4</td>
</tr>
<tr>
<td>1293</td>
<td>单调队列</td>
<td>31</td>
<td>31</td>
<td>62</td>
<td>7</td>
</tr>
<tr>
<td>1407</td>
<td>扩展欧几里得</td>
<td>32</td>
<td>30</td>
<td>62</td>
<td>5</td>
</tr>
<tr>
<td>1588</td>
<td>Splay/Set</td>
<td>27</td>
<td>35</td>
<td>62</td>
<td>4</td>
</tr>
<tr>
<td>1811</td>
<td>差分解方程</td>
<td>36</td>
<td>26</td>
<td>62</td>
<td>6</td>
</tr>
<tr>
<td>1879</td>
<td>状压DP</td>
<td>33</td>
<td>29</td>
<td>62</td>
<td>6</td>
</tr>
<tr>
<td>2190</td>
<td>线性筛欧拉函数</td>
<td>31</td>
<td>31</td>
<td>62</td>
<td>7</td>
</tr>
<tr>
<td>2426</td>
<td>贪心</td>
<td>33</td>
<td>29</td>
<td>62</td>
<td>4</td>
</tr>
<tr>
<td>2656</td>
<td>高精度</td>
<td>31</td>
<td>31</td>
<td>62</td>
<td>2</td>
</tr>
<tr>
<td>2751</td>
<td>快速幂+快速乘</td>
<td>31</td>
<td>31</td>
<td>62</td>
<td>6</td>
</tr>
<tr>
<td>3191</td>
<td>DP</td>
<td>36</td>
<td>26</td>
<td>62</td>
<td>6</td>
</tr>
<tr>
<td>3517</td>
<td>解方程</td>
<td>40</td>
<td>22</td>
<td>62</td>
<td>6</td>
</tr>
<tr>
<td>4233</td>
<td>递推</td>
<td>40</td>
<td>22</td>
<td>62</td>
<td>4</td>
</tr>
<tr>
<td>1031</td>
<td>后缀数组</td>
<td>27</td>
<td>36</td>
<td>63</td>
<td>6</td>
</tr>
<tr>
<td>1044</td>
<td>二分+DP</td>
<td>33</td>
<td>30</td>
<td>63</td>
<td>6</td>
</tr>
<tr>
<td>1076</td>
<td>期望DP</td>
<td>34</td>
<td>29</td>
<td>63</td>
<td>6</td>
</tr>
<tr>
<td>1089</td>
<td>递推+高精度</td>
<td>32</td>
<td>31</td>
<td>63</td>
<td>2</td>
</tr>
<tr>
<td>1103</td>
<td>树链剖分</td>
<td>27</td>
<td>36</td>
<td>63</td>
<td>6</td>
</tr>
<tr>
<td>1198</td>
<td>搜索</td>
<td>31</td>
<td>32</td>
<td>63</td>
<td>2</td>
</tr>
<tr>
<td>1208</td>
<td>Splay/Set</td>
<td>29</td>
<td>34</td>
<td>63</td>
<td>3</td>
</tr>
<tr>
<td>1216</td>
<td>堆</td>
<td>27</td>
<td>36</td>
<td>63</td>
<td>5</td>
</tr>
<tr>
<td>1224</td>
<td>DFS+剪枝</td>
<td>35</td>
<td>28</td>
<td>63</td>
<td>3</td>
</tr>
<tr>
<td>1257</td>
<td>数学</td>
<td>36</td>
<td>27</td>
<td>63</td>
<td>7</td>
</tr>
<tr>
<td>2150</td>
<td>二分图</td>
<td>32</td>
<td>31</td>
<td>63</td>
<td>8</td>
</tr>
<tr>
<td>2172</td>
<td>分类讨论+暴力</td>
<td>35</td>
<td>28</td>
<td>63</td>
<td>2</td>
</tr>
<tr>
<td>3155</td>
<td>树状数组</td>
<td>31</td>
<td>32</td>
<td>63</td>
<td>6</td>
</tr>
<tr>
<td>4008</td>
<td>期望DP</td>
<td>33</td>
<td>30</td>
<td>63</td>
<td>6</td>
</tr>
<tr>
<td>4318</td>
<td>期望</td>
<td>40</td>
<td>23</td>
<td>63</td>
<td></td>
</tr>
<tr>
<td>4403</td>
<td>卢卡斯</td>
<td>33</td>
<td>30</td>
<td>63</td>
<td></td>
</tr>
<tr>
<td>1269&amp;1507</td>
<td>Splay/STL</td>
<td>28</td>
<td>35</td>
<td>63</td>
<td>3</td>
</tr>
<tr>
<td>1416&amp;1498</td>
<td>高精度算概率</td>
<td>31</td>
<td>32</td>
<td>63</td>
<td>4</td>
</tr>
<tr>
<td>1010</td>
<td>DP单调性/斜率优化</td>
<td>32</td>
<td>32</td>
<td>64</td>
<td>8</td>
</tr>
<tr>
<td>1046</td>
<td>DP+贪心</td>
<td>34</td>
<td>30</td>
<td>64</td>
<td>5</td>
</tr>
<tr>
<td>1092</td>
<td>模拟</td>
<td>34</td>
<td>30</td>
<td>64</td>
<td>4</td>
</tr>
<tr>
<td>1259</td>
<td>打表</td>
<td>44</td>
<td>20</td>
<td>64</td>
<td>1</td>
</tr>
<tr>
<td>1304</td>
<td>树形DP</td>
<td>33</td>
<td>31</td>
<td>64</td>
<td>6</td>
</tr>
<tr>
<td>1406</td>
<td>数学</td>
<td>36</td>
<td>28</td>
<td>64</td>
<td>5</td>
</tr>
<tr>
<td>1820</td>
<td>DP</td>
<td>35</td>
<td>29</td>
<td>64</td>
<td>7</td>
</tr>
<tr>
<td>1996</td>
<td>DP</td>
<td>36</td>
<td>28</td>
<td>64</td>
<td>6</td>
</tr>
<tr>
<td>2153</td>
<td>DP斜率优化</td>
<td>32</td>
<td>32</td>
<td>64</td>
<td>5</td>
</tr>
<tr>
<td>2302</td>
<td>DP+组合数递推</td>
<td>35</td>
<td>29</td>
<td>64</td>
<td>6</td>
</tr>
<tr>
<td>2328</td>
<td>贪心</td>
<td>35</td>
<td>29</td>
<td>64</td>
<td>5</td>
</tr>
<tr>
<td>2338</td>
<td>计算几何+排序</td>
<td>32</td>
<td>32</td>
<td>64</td>
<td>6</td>
</tr>
<tr>
<td>2600</td>
<td>二分/单调性</td>
<td>34</td>
<td>30</td>
<td>64</td>
<td>6</td>
</tr>
<tr>
<td>2660</td>
<td>DP</td>
<td>32</td>
<td>32</td>
<td>64</td>
<td>5</td>
</tr>
<tr>
<td>2765</td>
<td>解方程</td>
<td>32</td>
<td>32</td>
<td>64</td>
<td>5</td>
</tr>
<tr>
<td>2824</td>
<td>搜索</td>
<td>34</td>
<td>30</td>
<td>64</td>
<td>2</td>
</tr>
<tr>
<td>2875</td>
<td>矩阵乘法</td>
<td>31</td>
<td>33</td>
<td>64</td>
<td>7</td>
</tr>
<tr>
<td>3175</td>
<td>二分图</td>
<td>33</td>
<td>31</td>
<td>64</td>
<td>9</td>
</tr>
<tr>
<td>3208</td>
<td>记忆化搜索</td>
<td>32</td>
<td>32</td>
<td>64</td>
<td>4</td>
</tr>
<tr>
<td>3223</td>
<td>Splay翻转</td>
<td>27</td>
<td>37</td>
<td>64</td>
<td>7</td>
</tr>
<tr>
<td>3224</td>
<td>Splay</td>
<td>26</td>
<td>38</td>
<td>64</td>
<td>8</td>
</tr>
<tr>
<td>3227</td>
<td>DP+打表</td>
<td>34</td>
<td>30</td>
<td>64</td>
<td>2</td>
</tr>
<tr>
<td>3288</td>
<td>线性筛+欧拉函数</td>
<td>32</td>
<td>32</td>
<td>64</td>
<td>6</td>
</tr>
<tr>
<td>3437</td>
<td>DP斜率优化</td>
<td>32</td>
<td>32</td>
<td>64</td>
<td>7</td>
</tr>
<tr>
<td>3444</td>
<td>数学</td>
<td>34</td>
<td>30</td>
<td>64</td>
<td>4</td>
</tr>
<tr>
<td>3612</td>
<td>DP</td>
<td>37</td>
<td>27</td>
<td>64</td>
<td>5</td>
</tr>
<tr>
<td>4321</td>
<td>DP</td>
<td>40</td>
<td>24</td>
<td>64</td>
<td></td>
</tr>
<tr>
<td>4401</td>
<td>枚举约数+树上统计</td>
<td>35</td>
<td>29</td>
<td>64</td>
<td></td>
</tr>
<tr>
<td>1007</td>
<td>单调栈</td>
<td>33</td>
<td>32</td>
<td>65</td>
<td>8</td>
</tr>
<tr>
<td>1048</td>
<td>记忆化搜索</td>
<td>34</td>
<td>31</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>1051</td>
<td>tarjan</td>
<td>30</td>
<td>35</td>
<td>65</td>
<td>5</td>
</tr>
<tr>
<td>1058</td>
<td>Splay/Set</td>
<td>29</td>
<td>36</td>
<td>65</td>
<td>4</td>
</tr>
<tr>
<td>1068</td>
<td>记忆化搜索</td>
<td>35</td>
<td>30</td>
<td>65</td>
<td>7</td>
</tr>
<tr>
<td>1087</td>
<td>状压DP</td>
<td>33</td>
<td>32</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>1202</td>
<td>并查集</td>
<td>33</td>
<td>32</td>
<td>65</td>
<td>8</td>
</tr>
<tr>
<td>1220</td>
<td>数学+高精度</td>
<td>34</td>
<td>31</td>
<td>65</td>
<td>2</td>
</tr>
<tr>
<td>1237</td>
<td>DP</td>
<td>39</td>
<td>26</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>1491</td>
<td>Floyd</td>
<td>33</td>
<td>32</td>
<td>65</td>
<td>7</td>
</tr>
<tr>
<td>1560</td>
<td>DP小优化</td>
<td>36</td>
<td>29</td>
<td>65</td>
<td>7</td>
</tr>
<tr>
<td>1801</td>
<td>DP</td>
<td>34</td>
<td>31</td>
<td>65</td>
<td>7</td>
</tr>
<tr>
<td>1864</td>
<td>树形DP</td>
<td>33</td>
<td>32</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>1899</td>
<td>DP</td>
<td>35</td>
<td>30</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>1911</td>
<td>DP斜率优化</td>
<td>32</td>
<td>33</td>
<td>65</td>
<td>8</td>
</tr>
<tr>
<td>1912</td>
<td>树上最长链</td>
<td>34</td>
<td>31</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>1925</td>
<td>DP</td>
<td>35</td>
<td>30</td>
<td>65</td>
<td>7</td>
</tr>
<tr>
<td>1966</td>
<td>DP</td>
<td>35</td>
<td>30</td>
<td>65</td>
<td>4</td>
</tr>
<tr>
<td>2049</td>
<td>LCT</td>
<td>27</td>
<td>38</td>
<td>65</td>
<td>7</td>
</tr>
<tr>
<td>2186</td>
<td>数学</td>
<td>32</td>
<td>33</td>
<td>65</td>
<td>7</td>
</tr>
<tr>
<td>2242</td>
<td>快速幂+逆元+BSGS</td>
<td>29</td>
<td>36</td>
<td>65</td>
<td>7</td>
</tr>
<tr>
<td>2335</td>
<td>分类讨论</td>
<td>39</td>
<td>26</td>
<td>65</td>
<td>3</td>
</tr>
<tr>
<td>2423</td>
<td>DP</td>
<td>36</td>
<td>29</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>2431</td>
<td>DP</td>
<td>35</td>
<td>30</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>2565</td>
<td>Manacher</td>
<td>33</td>
<td>32</td>
<td>65</td>
<td>7</td>
</tr>
<tr>
<td>2729</td>
<td>组合计数高精度</td>
<td>35</td>
<td>30</td>
<td>65</td>
<td>5</td>
</tr>
<tr>
<td>2822</td>
<td>卡特兰数+高精度</td>
<td>33</td>
<td>32</td>
<td>65</td>
<td>2</td>
</tr>
<tr>
<td>3156</td>
<td>DP斜率优化</td>
<td>32</td>
<td>33</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>3173</td>
<td>树状数组+倒求顺序</td>
<td>34</td>
<td>31</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>3190</td>
<td>单调栈</td>
<td>33</td>
<td>32</td>
<td>65</td>
<td>8</td>
</tr>
<tr>
<td>3212</td>
<td>线段树区间操作</td>
<td>27</td>
<td>38</td>
<td>65</td>
<td>9</td>
</tr>
<tr>
<td>3506</td>
<td>Splay</td>
<td>28</td>
<td>37</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>3609</td>
<td>博弈</td>
<td>40</td>
<td>25</td>
<td>65</td>
<td>4</td>
</tr>
<tr>
<td>3631</td>
<td>树链剖分</td>
<td>28</td>
<td>37</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>3643</td>
<td>暴力</td>
<td>33</td>
<td>32</td>
<td>65</td>
<td>4</td>
</tr>
<tr>
<td>4325</td>
<td>暴力</td>
<td>26</td>
<td>39</td>
<td>65</td>
<td></td>
</tr>
<tr>
<td>4385</td>
<td>单调队列</td>
<td>31</td>
<td>34</td>
<td>65</td>
<td></td>
</tr>
<tr>
<td>1787&amp;1832</td>
<td>LCA</td>
<td>31</td>
<td>34</td>
<td>65</td>
<td>6</td>
</tr>
<tr>
<td>1789&amp;1830</td>
<td>暴力</td>
<td>34</td>
<td>31</td>
<td>65</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<p><br><br></p>
<h3 id="弱省省选-NOI-难度"><a href="#弱省省选-NOI-难度" class="headerlink" title="弱省省选(NOI)难度"></a>弱省省选(NOI)难度</h3><div class="table-container">
<table>
<thead>
<tr>
<th>题号</th>
<th>算法</th>
<th>思想难度</th>
<th>实现难度</th>
<th>总难度</th>
<th>推荐指数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1003</td>
<td>DP+最短路</td>
<td>33</td>
<td>33</td>
<td>66</td>
<td>7</td>
</tr>
<tr>
<td>1029</td>
<td>贪心+堆</td>
<td>34</td>
<td>32</td>
<td>66</td>
<td>7</td>
</tr>
<tr>
<td>1032</td>
<td>错误DP</td>
<td>39</td>
<td>27</td>
<td>66</td>
<td>1</td>
</tr>
<tr>
<td>1037</td>
<td>DP</td>
<td>38</td>
<td>28</td>
<td>66</td>
<td>7</td>
</tr>
<tr>
<td>1057</td>
<td>DP悬线法</td>
<td>33</td>
<td>33</td>
<td>66</td>
<td>7</td>
</tr>
<tr>
<td>1060</td>
<td>树形DP</td>
<td>33</td>
<td>33</td>
<td>66</td>
<td>6</td>
</tr>
<tr>
<td>1086</td>
<td>树上DFS分块</td>
<td>33</td>
<td>33</td>
<td>66</td>
<td>2</td>
</tr>
<tr>
<td>1096</td>
<td>DP斜率优化</td>
<td>33</td>
<td>33</td>
<td>66</td>
<td>8</td>
</tr>
<tr>
<td>1149</td>
<td>DFS</td>
<td>34</td>
<td>32</td>
<td>66</td>
<td>6</td>
</tr>
<tr>
<td>1193</td>
<td>贪心+暴力</td>
<td>36</td>
<td>30</td>
<td>66</td>
<td>2</td>
</tr>
<tr>
<td>1196</td>
<td>二分+最小生成树</td>
<td>34</td>
<td>32</td>
<td>66</td>
<td>7</td>
</tr>
<tr>
<td>1212</td>
<td>Trie+DP</td>
<td>33</td>
<td>33</td>
<td>66</td>
<td>3</td>
</tr>
<tr>
<td>1222</td>
<td>DP</td>
<td>39</td>
<td>27</td>
<td>66</td>
<td>6</td>
</tr>
<tr>
<td>1806</td>
<td>DP</td>
<td>35</td>
<td>31</td>
<td>66</td>
<td>6</td>
</tr>
<tr>
<td>1819</td>
<td>暴力+字典树</td>
<td>32</td>
<td>34</td>
<td>66</td>
<td>2</td>
</tr>
<tr>
<td>1861</td>
<td>Splay</td>
<td>29</td>
<td>37</td>
<td>66</td>
<td>7</td>
</tr>
<tr>
<td>1932</td>
<td>STL</td>
<td>30</td>
<td>36</td>
<td>66</td>
<td>2</td>
</tr>
<tr>
<td>2120</td>
<td>暴力</td>
<td>38</td>
<td>28</td>
<td>66</td>
<td>2</td>
</tr>
<tr>
<td>2155</td>
<td>高精递推</td>
<td>39</td>
<td>27</td>
<td>66</td>
<td>4</td>
</tr>
<tr>
<td>2299</td>
<td>裴蜀定理</td>
<td>39</td>
<td>27</td>
<td>66</td>
<td>4</td>
</tr>
<tr>
<td>2330</td>
<td>差分约束</td>
<td>33</td>
<td>33</td>
<td>66</td>
<td>7</td>
</tr>
<tr>
<td>2461</td>
<td>DP</td>
<td>35</td>
<td>31</td>
<td>66</td>
<td>4</td>
</tr>
<tr>
<td>2466</td>
<td>树形DP</td>
<td>34</td>
<td>32</td>
<td>66</td>
<td>3</td>
</tr>
<tr>
<td>2657</td>
<td>构图+树上最长链</td>
<td>33</td>
<td>33</td>
<td>66</td>
<td>6</td>
</tr>
<tr>
<td>2762</td>
<td>树状数组</td>
<td>32</td>
<td>34</td>
<td>66</td>
<td>2</td>
</tr>
<tr>
<td>2819</td>
<td>树剖博弈</td>
<td>28</td>
<td>38</td>
<td>66</td>
<td>5</td>
</tr>
<tr>
<td>3170</td>
<td>曼哈顿距离</td>
<td>36</td>
<td>30</td>
<td>66</td>
<td>6</td>
</tr>
<tr>
<td>3172</td>
<td>AC自动机</td>
<td>30</td>
<td>36</td>
<td>66</td>
<td>9</td>
</tr>
<tr>
<td>3174</td>
<td>贪心+DP</td>
<td>36</td>
<td>30</td>
<td>66</td>
<td>6</td>
</tr>
<tr>
<td>3192</td>
<td>树状数组</td>
<td>34</td>
<td>32</td>
<td>66</td>
<td>5</td>
</tr>
<tr>
<td>3209</td>
<td>数位DP</td>
<td>34</td>
<td>32</td>
<td>66</td>
<td>5</td>
</tr>
<tr>
<td>3573</td>
<td>树形DP</td>
<td>33</td>
<td>33</td>
<td>66</td>
<td>4</td>
</tr>
<tr>
<td>3823</td>
<td>递推统计</td>
<td>35</td>
<td>31</td>
<td>66</td>
<td>4</td>
</tr>
<tr>
<td>3997</td>
<td>DP</td>
<td>37</td>
<td>29</td>
<td>66</td>
<td>5</td>
</tr>
<tr>
<td>1042</td>
<td>背包DP+容斥原理</td>
<td>35</td>
<td>32</td>
<td>67</td>
<td>7</td>
</tr>
<tr>
<td>1072</td>
<td>状压DP</td>
<td>35</td>
<td>32</td>
<td>67</td>
<td>6</td>
</tr>
<tr>
<td>1082</td>
<td>二分+搜索判断</td>
<td>34</td>
<td>33</td>
<td>67</td>
<td>6</td>
</tr>
<tr>
<td>1090</td>
<td>区间DP</td>
<td>35</td>
<td>32</td>
<td>67</td>
<td>7</td>
</tr>
<tr>
<td>1225</td>
<td>搜索+剪枝+高精</td>
<td>33</td>
<td>34</td>
<td>67</td>
<td>2</td>
</tr>
<tr>
<td>1277</td>
<td>DP</td>
<td>36</td>
<td>31</td>
<td>67</td>
<td>5</td>
</tr>
<tr>
<td>1486</td>
<td>二分+DFS找负环</td>
<td>34</td>
<td>33</td>
<td>67</td>
<td>8</td>
</tr>
<tr>
<td>1564</td>
<td>区间DP</td>
<td>35</td>
<td>32</td>
<td>67</td>
<td>6</td>
</tr>
<tr>
<td>1794</td>
<td>DP</td>
<td>37</td>
<td>30</td>
<td>67</td>
<td>5</td>
</tr>
<tr>
<td>1798</td>
<td>线段树</td>
<td>29</td>
<td>38</td>
<td>67</td>
<td>9</td>
</tr>
<tr>
<td>1860</td>
<td>DP</td>
<td>34</td>
<td>33</td>
<td>67</td>
<td>6</td>
</tr>
<tr>
<td>2281</td>
<td>博弈+DP</td>
<td>39</td>
<td>28</td>
<td>67</td>
<td>5</td>
</tr>
<tr>
<td>2440</td>
<td>二分+莫比乌斯容斥</td>
<td>34</td>
<td>33</td>
<td>67</td>
<td>6</td>
</tr>
<tr>
<td>2458</td>
<td>分治计算几何</td>
<td>34</td>
<td>33</td>
<td>67</td>
<td>7</td>
</tr>
<tr>
<td>2667</td>
<td>暴枚+解方程判断</td>
<td>35</td>
<td>32</td>
<td>67</td>
<td>6</td>
</tr>
<tr>
<td>2746</td>
<td>BFS</td>
<td>30</td>
<td>37</td>
<td>67</td>
<td>3</td>
</tr>
<tr>
<td>2767</td>
<td>DP</td>
<td>37</td>
<td>30</td>
<td>67</td>
<td>6</td>
</tr>
<tr>
<td>2809</td>
<td>可并堆</td>
<td>33</td>
<td>34</td>
<td>67</td>
<td>8</td>
</tr>
<tr>
<td>2818</td>
<td>欧拉函数/莫比乌斯反演</td>
<td>34</td>
<td>33</td>
<td>67</td>
<td>7</td>
</tr>
<tr>
<td>3107</td>
<td>构造</td>
<td>40</td>
<td>27</td>
<td>67</td>
<td>5</td>
</tr>
<tr>
<td>3226</td>
<td>线段树</td>
<td>30</td>
<td>37</td>
<td>67</td>
<td>4</td>
</tr>
<tr>
<td>3287</td>
<td>高精度</td>
<td>32</td>
<td>35</td>
<td>67</td>
<td>2</td>
</tr>
<tr>
<td>3555</td>
<td>HASH</td>
<td>34</td>
<td>33</td>
<td>67</td>
<td>5</td>
</tr>
<tr>
<td>4196</td>
<td>树链剖分</td>
<td>29</td>
<td>38</td>
<td>67</td>
<td>7</td>
</tr>
<tr>
<td>4236</td>
<td>MAP</td>
<td>35</td>
<td>32</td>
<td>67</td>
<td>6</td>
</tr>
<tr>
<td>4347</td>
<td>DP</td>
<td>38</td>
<td>29</td>
<td>67</td>
<td></td>
</tr>
<tr>
<td>4366</td>
<td>DP讨论</td>
<td>46</td>
<td>21</td>
<td>67</td>
<td></td>
</tr>
<tr>
<td>1180/2843</td>
<td>LCT</td>
<td>28</td>
<td>39</td>
<td>67</td>
<td>5</td>
</tr>
<tr>
<td>1786&amp;1831</td>
<td>DP</td>
<td>36</td>
<td>31</td>
<td>67</td>
<td>5</td>
</tr>
<tr>
<td>1408</td>
<td>数论</td>
<td>40</td>
<td>28</td>
<td>68</td>
<td>2</td>
</tr>
<tr>
<td>1412</td>
<td>网络流</td>
<td>33</td>
<td>35</td>
<td>68</td>
<td>5</td>
</tr>
<tr>
<td>1434</td>
<td>博弈论</td>
<td>43</td>
<td>25</td>
<td>68</td>
<td>5</td>
</tr>
<tr>
<td>1497</td>
<td>最小割</td>
<td>33</td>
<td>35</td>
<td>68</td>
<td>9</td>
</tr>
<tr>
<td>1503</td>
<td>Splay</td>
<td>30</td>
<td>38</td>
<td>68</td>
<td>8</td>
</tr>
<tr>
<td>1562</td>
<td>二分图DFS序</td>
<td>34</td>
<td>34</td>
<td>68</td>
<td>8</td>
</tr>
<tr>
<td>1567</td>
<td>二分+HASH</td>
<td>34</td>
<td>34</td>
<td>68</td>
<td>5</td>
</tr>
<tr>
<td>1597</td>
<td>排序+DP斜率优化</td>
<td>34</td>
<td>34</td>
<td>68</td>
<td>8</td>
</tr>
<tr>
<td>1826</td>
<td>贪心+堆</td>
<td>35</td>
<td>33</td>
<td>68</td>
<td>7</td>
</tr>
<tr>
<td>1833</td>
<td>数位DP</td>
<td>34</td>
<td>34</td>
<td>68</td>
<td>7</td>
</tr>
<tr>
<td>1922</td>
<td>Dijkstra堆优</td>
<td>33</td>
<td>35</td>
<td>68</td>
<td>9</td>
</tr>
<tr>
<td>2038</td>
<td>莫队</td>
<td>32</td>
<td>36</td>
<td>68</td>
<td>9</td>
</tr>
<tr>
<td>2111</td>
<td>排列组合</td>
<td>34</td>
<td>34</td>
<td>68</td>
<td>3</td>
</tr>
<tr>
<td>2118</td>
<td>最短路</td>
<td>35</td>
<td>33</td>
<td>68</td>
<td>8</td>
</tr>
<tr>
<td>2160</td>
<td>Manacher+快速幂</td>
<td>34</td>
<td>34</td>
<td>68</td>
<td>7</td>
</tr>
<tr>
<td>2227</td>
<td>高精算概率</td>
<td>35</td>
<td>33</td>
<td>68</td>
<td>2</td>
</tr>
<tr>
<td>2654</td>
<td>二分+最小生成树</td>
<td>35</td>
<td>33</td>
<td>68</td>
<td>6</td>
</tr>
<tr>
<td>2661</td>
<td>费用流</td>
<td>34</td>
<td>34</td>
<td>68</td>
<td>6</td>
</tr>
<tr>
<td>2823</td>
<td>最小圆覆盖</td>
<td>29</td>
<td>39</td>
<td>68</td>
<td>7</td>
</tr>
<tr>
<td>3111</td>
<td>DP</td>
<td>35</td>
<td>33</td>
<td>68</td>
<td>6</td>
</tr>
<tr>
<td>3207</td>
<td>HASH/莫队/主席树</td>
<td>31</td>
<td>37</td>
<td>68</td>
<td>2</td>
</tr>
<tr>
<td>3211</td>
<td>暴力并查集+树状数组</td>
<td>35</td>
<td>33</td>
<td>68</td>
<td>4</td>
</tr>
<tr>
<td>3225</td>
<td>线段树扫描</td>
<td>32</td>
<td>36</td>
<td>68</td>
<td>2</td>
</tr>
<tr>
<td>3233</td>
<td>线性筛+DP</td>
<td>36</td>
<td>32</td>
<td>68</td>
<td>6</td>
</tr>
<tr>
<td>3442</td>
<td>费用流</td>
<td>34</td>
<td>34</td>
<td>68</td>
<td>6</td>
</tr>
<tr>
<td>3670</td>
<td>KMP</td>
<td>34</td>
<td>34</td>
<td>68</td>
<td>6</td>
</tr>
<tr>
<td>4337</td>
<td>HASH判树同构</td>
<td>33</td>
<td>35</td>
<td>68</td>
<td>4</td>
</tr>
<tr>
<td>4364</td>
<td>线段树</td>
<td>31</td>
<td>37</td>
<td>68</td>
<td></td>
</tr>
<tr>
<td>4378</td>
<td>树状数组</td>
<td>34</td>
<td>34</td>
<td>68</td>
<td></td>
</tr>
<tr>
<td>1056&amp;1862</td>
<td>Trie+Splay</td>
<td>28</td>
<td>40</td>
<td>68</td>
<td>3</td>
</tr>
<tr>
<td>1043</td>
<td>计算几何+贪心</td>
<td>33</td>
<td>36</td>
<td>69</td>
<td>7</td>
</tr>
<tr>
<td>1066</td>
<td>网络流</td>
<td>34</td>
<td>35</td>
<td>69</td>
<td>8</td>
</tr>
<tr>
<td>1221</td>
<td>费用流</td>
<td>35</td>
<td>34</td>
<td>69</td>
<td>9</td>
</tr>
<tr>
<td>1264</td>
<td>树状数组优化DP</td>
<td>36</td>
<td>33</td>
<td>69</td>
<td>5</td>
</tr>
<tr>
<td>1411</td>
<td>推猜结论</td>
<td>41</td>
<td>28</td>
<td>69</td>
<td>6</td>
</tr>
<tr>
<td>1855</td>
<td>DP+单调队列</td>
<td>35</td>
<td>34</td>
<td>69</td>
<td>8</td>
</tr>
<tr>
<td>1858</td>
<td>线段树各种操作</td>
<td>30</td>
<td>39</td>
<td>69</td>
<td>8</td>
</tr>
<tr>
<td>2002</td>
<td>LCT</td>
<td>31</td>
<td>38</td>
<td>69</td>
<td>6</td>
</tr>
<tr>
<td>2131</td>
<td>树状数组优化DP</td>
<td>36</td>
<td>33</td>
<td>69</td>
<td>7</td>
</tr>
<tr>
<td>2157</td>
<td>LCT多种操作</td>
<td>29</td>
<td>40</td>
<td>69</td>
<td>7</td>
</tr>
<tr>
<td>2226</td>
<td>数学</td>
<td>36</td>
<td>33</td>
<td>69</td>
<td>7</td>
</tr>
<tr>
<td>2298</td>
<td>DP</td>
<td>40</td>
<td>29</td>
<td>69</td>
<td>6</td>
</tr>
<tr>
<td>2460</td>
<td>拟阵+线性基</td>
<td>37</td>
<td>32</td>
<td>69</td>
<td>6</td>
</tr>
<tr>
<td>3105</td>
<td>拟阵+线性基</td>
<td>37</td>
<td>32</td>
<td>69</td>
<td>6</td>
</tr>
<tr>
<td>3195</td>
<td>状压DP</td>
<td>37</td>
<td>32</td>
<td>69</td>
<td>5</td>
</tr>
<tr>
<td>3289</td>
<td>莫队+BIT</td>
<td>32</td>
<td>37</td>
<td>69</td>
<td>6</td>
</tr>
<tr>
<td>3316</td>
<td>二分+单调队列</td>
<td>35</td>
<td>34</td>
<td>69</td>
<td>6</td>
</tr>
<tr>
<td>3671</td>
<td>贪心</td>
<td>36</td>
<td>33</td>
<td>69</td>
<td>7</td>
</tr>
<tr>
<td>3675</td>
<td>多维DP斜率优化</td>
<td>34</td>
<td>35</td>
<td>69</td>
<td>6</td>
</tr>
<tr>
<td>3884</td>
<td>费马+欧拉函数+快速幂</td>
<td>37</td>
<td>32</td>
<td>69</td>
<td>6</td>
</tr>
<tr>
<td>4004</td>
<td>线性基</td>
<td>36</td>
<td>33</td>
<td>69</td>
<td>8</td>
</tr>
<tr>
<td>4034</td>
<td>DFS序维护树</td>
<td>31</td>
<td>38</td>
<td>69</td>
<td>8</td>
</tr>
<tr>
<td>4084</td>
<td>HASH</td>
<td>32</td>
<td>37</td>
<td>69</td>
<td>5</td>
</tr>
<tr>
<td>4320</td>
<td>分块</td>
<td>36</td>
<td>33</td>
<td>69</td>
<td></td>
</tr>
<tr>
<td>1006</td>
<td>弦图染色</td>
<td>40</td>
<td>30</td>
<td>70</td>
<td>2</td>
</tr>
<tr>
<td>1041</td>
<td>数学</td>
<td>44</td>
<td>26</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>1052</td>
<td>二分+DFS</td>
<td>37</td>
<td>33</td>
<td>70</td>
<td>4</td>
</tr>
<tr>
<td>1150</td>
<td>贪心+堆</td>
<td>38</td>
<td>32</td>
<td>70</td>
<td>8</td>
</tr>
<tr>
<td>1151</td>
<td>状压DP</td>
<td>36</td>
<td>34</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>1188</td>
<td>博弈论SG函数</td>
<td>37</td>
<td>33</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>1483</td>
<td>链表启发式合并</td>
<td>35</td>
<td>35</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>1566</td>
<td>DP</td>
<td>38</td>
<td>32</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>1570</td>
<td>二分+网络流</td>
<td>35</td>
<td>35</td>
<td>70</td>
<td>4</td>
</tr>
<tr>
<td>1818</td>
<td>离散化+树状数组</td>
<td>35</td>
<td>35</td>
<td>70</td>
<td>5</td>
</tr>
<tr>
<td>1857</td>
<td>三分套三分</td>
<td>34</td>
<td>36</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>1877</td>
<td>费用流</td>
<td>36</td>
<td>34</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>1878</td>
<td>离线树状数组</td>
<td>36</td>
<td>34</td>
<td>70</td>
<td>8</td>
</tr>
<tr>
<td>1898</td>
<td>矩阵乘法</td>
<td>35</td>
<td>35</td>
<td>70</td>
<td>6</td>
</tr>
<tr>
<td>1923</td>
<td>高斯消元</td>
<td>36</td>
<td>34</td>
<td>70</td>
<td>8</td>
</tr>
<tr>
<td>2037</td>
<td>区间DP</td>
<td>39</td>
<td>31</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>2152</td>
<td>点分治</td>
<td>33</td>
<td>37</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>2243</td>
<td>树链剖分</td>
<td>30</td>
<td>40</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>2339</td>
<td>排列组合+快速幂</td>
<td>40</td>
<td>30</td>
<td>70</td>
<td>5</td>
</tr>
<tr>
<td>2424</td>
<td>费用流</td>
<td>36</td>
<td>34</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>2439</td>
<td>DP单调优化+扫描</td>
<td>37</td>
<td>33</td>
<td>70</td>
<td>5</td>
</tr>
<tr>
<td>2468</td>
<td>数学公式优化</td>
<td>38</td>
<td>32</td>
<td>70</td>
<td>6</td>
</tr>
<tr>
<td>2666</td>
<td>贪心调整</td>
<td>40</td>
<td>30</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>2957</td>
<td>分块</td>
<td>35</td>
<td>35</td>
<td>70</td>
<td>6</td>
</tr>
<tr>
<td>3109</td>
<td>搜索</td>
<td>32</td>
<td>38</td>
<td>70</td>
<td>5</td>
</tr>
<tr>
<td>3124</td>
<td>树形DP</td>
<td>36</td>
<td>34</td>
<td>70</td>
<td>6</td>
</tr>
<tr>
<td>3193</td>
<td>DP</td>
<td>40</td>
<td>30</td>
<td>70</td>
<td>6</td>
</tr>
<tr>
<td>3240</td>
<td>费马小定理+矩阵乘法</td>
<td>35</td>
<td>35</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>3436</td>
<td>差分约束+判负环</td>
<td>36</td>
<td>34</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>3531</td>
<td>树链剖分</td>
<td>30</td>
<td>40</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>3562</td>
<td>缩点+并查集</td>
<td>35</td>
<td>35</td>
<td>70</td>
<td>2</td>
</tr>
<tr>
<td>3624</td>
<td>最小生成树+贪心</td>
<td>37</td>
<td>33</td>
<td>70</td>
<td>6</td>
</tr>
<tr>
<td>3676</td>
<td>回文自动机</td>
<td>33</td>
<td>37</td>
<td>70</td>
<td>8</td>
</tr>
<tr>
<td>3680</td>
<td>模拟退火</td>
<td>33</td>
<td>37</td>
<td>70</td>
<td>8</td>
</tr>
<tr>
<td>3685</td>
<td>线段树</td>
<td>31</td>
<td>39</td>
<td>70</td>
<td>4</td>
</tr>
<tr>
<td>3732</td>
<td>Kruskal+树上倍增</td>
<td>34</td>
<td>36</td>
<td>70</td>
<td>8</td>
</tr>
<tr>
<td>3813</td>
<td>线段树+逆元</td>
<td>32</td>
<td>38</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>3930</td>
<td>数学</td>
<td>41</td>
<td>29</td>
<td>70</td>
<td>4</td>
</tr>
<tr>
<td>3993</td>
<td>二分+网络流</td>
<td>35</td>
<td>35</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>4003</td>
<td>可并堆</td>
<td>34</td>
<td>36</td>
<td>70</td>
<td>8</td>
</tr>
<tr>
<td>4027</td>
<td>树形DP</td>
<td>37</td>
<td>33</td>
<td>70</td>
<td>5</td>
</tr>
<tr>
<td>4031</td>
<td>矩阵树定理</td>
<td>35</td>
<td>35</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>4198</td>
<td>K叉哈夫曼</td>
<td>37</td>
<td>33</td>
<td>70</td>
<td>7</td>
</tr>
<tr>
<td>4319</td>
<td>构造SA</td>
<td>40</td>
<td>30</td>
<td>70</td>
<td>5</td>
</tr>
<tr>
<td>4338</td>
<td>分解质因数</td>
<td>38</td>
<td>32</td>
<td>70</td>
<td></td>
</tr>
<tr>
<td>4349</td>
<td>最小树形图</td>
<td>31</td>
<td>39</td>
<td>70</td>
<td>8</td>
</tr>
<tr>
<td>4370</td>
<td>线段树</td>
<td>30</td>
<td>40</td>
<td>70</td>
<td></td>
</tr>
<tr>
<td>1040</td>
<td>环+外向树DP</td>
<td>34</td>
<td>37</td>
<td>71</td>
<td>8</td>
</tr>
<tr>
<td>1063</td>
<td>树形DP</td>
<td>37</td>
<td>34</td>
<td>71</td>
<td>8</td>
</tr>
<tr>
<td>1070</td>
<td>费用流</td>
<td>37</td>
<td>34</td>
<td>71</td>
<td>7</td>
</tr>
<tr>
<td>1071</td>
<td>单调扫描</td>
<td>38</td>
<td>33</td>
<td>71</td>
<td>7</td>
</tr>
<tr>
<td>1143</td>
<td>Floyd+二分图</td>
<td>38</td>
<td>33</td>
<td>71</td>
<td>8</td>
</tr>
<tr>
<td>1217</td>
<td>树形贪心</td>
<td>38</td>
<td>33</td>
<td>71</td>
<td>7</td>
</tr>
<tr>
<td>1297</td>
<td>矩阵乘法</td>
<td>37</td>
<td>34</td>
<td>71</td>
<td>8</td>
</tr>
<tr>
<td>1415</td>
<td>期望+记忆化DP</td>
<td>37</td>
<td>34</td>
<td>71</td>
<td>8</td>
</tr>
<tr>
<td>1484</td>
<td>贪心调整</td>
<td>42</td>
<td>29</td>
<td>71</td>
<td>7</td>
</tr>
<tr>
<td>1799</td>
<td>数位DP</td>
<td>36</td>
<td>35</td>
<td>71</td>
<td>6</td>
</tr>
<tr>
<td>1834</td>
<td>最大流+费用流</td>
<td>34</td>
<td>37</td>
<td>71</td>
<td>5</td>
</tr>
<tr>
<td>1910</td>
<td>DP</td>
<td>38</td>
<td>33</td>
<td>71</td>
<td>6</td>
</tr>
<tr>
<td>1935</td>
<td>离线树状数组</td>
<td>36</td>
<td>35</td>
<td>71</td>
<td>5</td>
</tr>
<tr>
<td>1975</td>
<td>K短路</td>
<td>33</td>
<td>38</td>
<td>71</td>
<td>7</td>
</tr>
<tr>
<td>2133</td>
<td>树形DP</td>
<td>37</td>
<td>34</td>
<td>71</td>
<td>6</td>
</tr>
<tr>
<td>2151</td>
<td>双向链表+贪心+堆</td>
<td>37</td>
<td>34</td>
<td>71</td>
<td>8</td>
</tr>
<tr>
<td>2169</td>
<td>DP</td>
<td>41</td>
<td>30</td>
<td>71</td>
<td>7</td>
</tr>
<tr>
<td>2245</td>
<td>费用流</td>
<td>36</td>
<td>35</td>
<td>71</td>
<td>6</td>
</tr>
<tr>
<td>2257</td>
<td>裴蜀定理</td>
<td>38</td>
<td>33</td>
<td>71</td>
<td>4</td>
</tr>
<tr>
<td>2306</td>
<td>倍增+Floyd</td>
<td>37</td>
<td>34</td>
<td>71</td>
<td>7</td>
</tr>
<tr>
<td>2326</td>
<td>矩阵乘法</td>
<td>37</td>
<td>34</td>
<td>71</td>
<td>5</td>
</tr>
<tr>
<td>2337</td>
<td>期望高斯消元</td>
<td>36</td>
<td>35</td>
<td>71</td>
<td>7</td>
</tr>
<tr>
<td>2542</td>
<td>费用流</td>
<td>35</td>
<td>36</td>
<td>71</td>
<td>4</td>
</tr>
<tr>
<td>2560</td>
<td>子集DP</td>
<td>39</td>
<td>32</td>
<td>71</td>
<td>7</td>
</tr>
<tr>
<td>2743</td>
<td>离线树状数组</td>
<td>36</td>
<td>35</td>
<td>71</td>
<td>8</td>
</tr>
<tr>
<td>3130</td>
<td>二分+网络流</td>
<td>36</td>
<td>35</td>
<td>71</td>
<td>7</td>
</tr>
<tr>
<td>3231</td>
<td>矩阵乘法</td>
<td>35</td>
<td>36</td>
<td>71</td>
<td>4</td>
</tr>
<tr>
<td>3560</td>
<td>数论</td>
<td>37</td>
<td>34</td>
<td>71</td>
<td>6</td>
</tr>
<tr>
<td>3566</td>
<td>树形DP</td>
<td>38</td>
<td>33</td>
<td>71</td>
<td>6</td>
</tr>
<tr>
<td>3996</td>
<td>网络流</td>
<td>36</td>
<td>35</td>
<td>71</td>
<td>5</td>
</tr>
<tr>
<td>4029</td>
<td>模拟</td>
<td>39</td>
<td>32</td>
<td>71</td>
<td>4</td>
</tr>
<tr>
<td>4240</td>
<td>树状数组</td>
<td>40</td>
<td>31</td>
<td>71</td>
<td></td>
</tr>
<tr>
<td>4244</td>
<td>DP</td>
<td>41</td>
<td>30</td>
<td>71</td>
<td></td>
</tr>
<tr>
<td>4312</td>
<td>分类讨论</td>
<td>43</td>
<td>28</td>
<td>71</td>
<td>4</td>
</tr>
<tr>
<td>4326</td>
<td>树剖/讨论求链交</td>
<td>32</td>
<td>39</td>
<td>71</td>
<td>7</td>
</tr>
<tr>
<td>1306&amp;3139</td>
<td>搜索+剪枝</td>
<td>40</td>
<td>31</td>
<td>71</td>
<td>6</td>
</tr>
<tr>
<td>2662&amp;2763</td>
<td>分层图+Dijkstra堆优化</td>
<td>35</td>
<td>36</td>
<td>71</td>
<td>8</td>
</tr>
<tr>
<td>1005</td>
<td>Prufer</td>
<td>37</td>
<td>35</td>
<td>72</td>
<td>7</td>
</tr>
<tr>
<td>1061</td>
<td>单纯形</td>
<td>34</td>
<td>38</td>
<td>72</td>
<td>8</td>
</tr>
<tr>
<td>1069</td>
<td>旋转卡壳</td>
<td>33</td>
<td>39</td>
<td>72</td>
<td>8</td>
</tr>
<tr>
<td>1093</td>
<td>tarjan缩点+DP</td>
<td>36</td>
<td>36</td>
<td>72</td>
<td>9</td>
</tr>
<tr>
<td>1179</td>
<td>tarjan缩点+SPFA</td>
<td>35</td>
<td>37</td>
<td>72</td>
<td>9</td>
</tr>
<tr>
<td>1211</td>
<td>Prufer</td>
<td>39</td>
<td>33</td>
<td>72</td>
<td>3</td>
</tr>
<tr>
<td>1227</td>
<td>离散化+树状数组扫描</td>
<td>35</td>
<td>37</td>
<td>72</td>
<td>7</td>
</tr>
<tr>
<td>1266</td>
<td>最短路+最小割</td>
<td>35</td>
<td>37</td>
<td>72</td>
<td>8</td>
</tr>
<tr>
<td>1499</td>
<td>DP单调优化</td>
<td>35</td>
<td>37</td>
<td>72</td>
<td>6</td>
</tr>
<tr>
<td>1568</td>
<td>线段树</td>
<td>34</td>
<td>38</td>
<td>72</td>
<td>6</td>
</tr>
<tr>
<td>1823</td>
<td>2-SAT</td>
<td>36</td>
<td>36</td>
<td>72</td>
<td>7</td>
</tr>
<tr>
<td>1853</td>
<td>搜索+剪枝+容斥原理</td>
<td>39</td>
<td>33</td>
<td>72</td>
<td>6</td>
</tr>
<tr>
<td>1927</td>
<td>费用流</td>
<td>38</td>
<td>34</td>
<td>72</td>
<td>9</td>
</tr>
<tr>
<td>2142</td>
<td>扩展lucas</td>
<td>33</td>
<td>39</td>
<td>72</td>
<td>8</td>
</tr>
<tr>
<td>2163</td>
<td>最小割</td>
<td>37</td>
<td>35</td>
<td>72</td>
<td>4</td>
</tr>
<tr>
<td>2438</td>
<td>tarjan缩点</td>
<td>36</td>
<td>36</td>
<td>72</td>
<td>4</td>
</tr>
<tr>
<td>2588</td>
<td>DFS序+可持久化线段树</td>
<td>31</td>
<td>41</td>
<td>72</td>
<td>8</td>
</tr>
<tr>
<td>2733</td>
<td>Splay启发式合并</td>
<td>33</td>
<td>39</td>
<td>72</td>
<td>7</td>
</tr>
<tr>
<td>2742</td>
<td>数论</td>
<td>39</td>
<td>33</td>
<td>72</td>
<td>5</td>
</tr>
<tr>
<td>2749</td>
<td>转化后递推</td>
<td>42</td>
<td>30</td>
<td>72</td>
<td>6</td>
</tr>
<tr>
<td>2753</td>
<td>最小生成树</td>
<td>40</td>
<td>32</td>
<td>72</td>
<td>5</td>
</tr>
<tr>
<td>2816</td>
<td>LCT</td>
<td>31</td>
<td>41</td>
<td>72</td>
<td>5</td>
</tr>
<tr>
<td>2827</td>
<td>动态开点线段树</td>
<td>32</td>
<td>40</td>
<td>72</td>
<td>6</td>
</tr>
<tr>
<td>2962</td>
<td>线段树</td>
<td>33</td>
<td>39</td>
<td>72</td>
<td>7</td>
</tr>
<tr>
<td>2964</td>
<td>DP</td>
<td>36</td>
<td>36</td>
<td>72</td>
<td>5</td>
</tr>
<tr>
<td>3143</td>
<td>期望高斯消元</td>
<td>36</td>
<td>36</td>
<td>72</td>
<td>8</td>
</tr>
<tr>
<td>3144</td>
<td>最小割</td>
<td>37</td>
<td>35</td>
<td>72</td>
<td>6</td>
</tr>
<tr>
<td>3150</td>
<td>高斯消元</td>
<td>38</td>
<td>34</td>
<td>72</td>
<td>6</td>
</tr>
<tr>
<td>3152</td>
<td>贪心+堆</td>
<td>37</td>
<td>35</td>
<td>72</td>
<td>4</td>
</tr>
<tr>
<td>3295</td>
<td>分块统计动态逆序对</td>
<td>34</td>
<td>38</td>
<td>72</td>
<td>8</td>
</tr>
<tr>
<td>3333</td>
<td>BIT+线段树</td>
<td>34</td>
<td>38</td>
<td>72</td>
<td>5</td>
</tr>
<tr>
<td>3507</td>
<td>HASH+DP</td>
<td>37</td>
<td>35</td>
<td>72</td>
<td>5</td>
</tr>
<tr>
<td>3570</td>
<td>物理+树状数组</td>
<td>38</td>
<td>34</td>
<td>72</td>
<td>3</td>
</tr>
<tr>
<td>3576</td>
<td>博弈论+分块</td>
<td>41</td>
<td>31</td>
<td>72</td>
<td>6</td>
</tr>
<tr>
<td>3578</td>
<td>Set+rand Hash</td>
<td>36</td>
<td>36</td>
<td>72</td>
<td>4</td>
</tr>
<tr>
<td>3594</td>
<td>DP树状数组优化</td>
<td>39</td>
<td>33</td>
<td>72</td>
<td>4</td>
</tr>
<tr>
<td>3620</td>
<td>暴力+KMP</td>
<td>38</td>
<td>34</td>
<td>72</td>
<td>2</td>
</tr>
<tr>
<td>3629</td>
<td>判素数+约数和公式+暴力</td>
<td>38</td>
<td>34</td>
<td>72</td>
<td>4</td>
</tr>
<tr>
<td>3679</td>
<td>数位DP</td>
<td>36</td>
<td>36</td>
<td>72</td>
<td>5</td>
</tr>
<tr>
<td>3738</td>
<td>扩展lucas</td>
<td>32</td>
<td>40</td>
<td>72</td>
<td>5</td>
</tr>
<tr>
<td>3810</td>
<td>记忆化+卡常</td>
<td>37</td>
<td>35</td>
<td>72</td>
<td>6</td>
</tr>
<tr>
<td>3944</td>
<td>杜教筛</td>
<td>36</td>
<td>36</td>
<td>72</td>
<td>8</td>
</tr>
<tr>
<td>3673&amp;3674</td>
<td>可持久化ROPE</td>
<td>36</td>
<td>36</td>
<td>72</td>
<td>4</td>
</tr>
<tr>
<td>1016</td>
<td>最小生成树+DFS</td>
<td>40</td>
<td>33</td>
<td>73</td>
<td>6</td>
</tr>
<tr>
<td>1030</td>
<td>AC自动机+DP</td>
<td>36</td>
<td>37</td>
<td>73</td>
<td>8</td>
</tr>
<tr>
<td>1077</td>
<td>差分约束+Floyd</td>
<td>39</td>
<td>34</td>
<td>73</td>
<td>8</td>
</tr>
<tr>
<td>1085</td>
<td>A*</td>
<td>38</td>
<td>35</td>
<td>73</td>
<td>8</td>
</tr>
<tr>
<td>1177</td>
<td>分类讨论</td>
<td>36</td>
<td>37</td>
<td>73</td>
<td>4</td>
</tr>
<tr>
<td>1189</td>
<td>二分+网络流</td>
<td>37</td>
<td>36</td>
<td>73</td>
<td>6</td>
</tr>
<tr>
<td>1223</td>
<td>数位DP+高精度</td>
<td>36</td>
<td>37</td>
<td>73</td>
<td>2</td>
</tr>
<tr>
<td>1812</td>
<td>树形DP</td>
<td>40</td>
<td>33</td>
<td>73</td>
<td>8</td>
</tr>
<tr>
<td>1822</td>
<td>二分+网络流</td>
<td>35</td>
<td>38</td>
<td>73</td>
<td>4</td>
</tr>
<tr>
<td>1933</td>
<td>DP</td>
<td>41</td>
<td>32</td>
<td>73</td>
<td>7</td>
</tr>
<tr>
<td>1951</td>
<td>卢卡斯+CRT</td>
<td>38</td>
<td>35</td>
<td>73</td>
<td>7</td>
</tr>
<tr>
<td>2115</td>
<td>找环+线性基</td>
<td>38</td>
<td>35</td>
<td>73</td>
<td>8</td>
</tr>
<tr>
<td>2124</td>
<td>分类讨论分治+Cheat</td>
<td>40</td>
<td>33</td>
<td>73</td>
<td>2</td>
</tr>
<tr>
<td>2141</td>
<td>分块统计动态逆序对</td>
<td>34</td>
<td>39</td>
<td>73</td>
<td>8</td>
</tr>
<tr>
<td>2146</td>
<td>凸包+单调队列</td>
<td>37</td>
<td>36</td>
<td>73</td>
<td>5</td>
</tr>
<tr>
<td>2425</td>
<td>数位DP</td>
<td>40</td>
<td>33</td>
<td>73</td>
<td>6</td>
</tr>
<tr>
<td>2427</td>
<td>tarjan缩点+树上背包</td>
<td>36</td>
<td>37</td>
<td>73</td>
<td>7</td>
</tr>
<tr>
<td>2523</td>
<td>智商题</td>
<td>45</td>
<td>28</td>
<td>73</td>
<td>3</td>
</tr>
<tr>
<td>2618</td>
<td>半平面交</td>
<td>30</td>
<td>43</td>
<td>73</td>
<td>5</td>
</tr>
<tr>
<td>2752</td>
<td>线段树大力维护</td>
<td>33</td>
<td>40</td>
<td>73</td>
<td>7</td>
</tr>
<tr>
<td>2844</td>
<td>拟阵+线性基+找规律</td>
<td>40</td>
<td>33</td>
<td>73</td>
<td>6</td>
</tr>
<tr>
<td>3085</td>
<td>搜索+剪枝+高精度</td>
<td>35</td>
<td>38</td>
<td>73</td>
<td>2</td>
</tr>
<tr>
<td>3140</td>
<td>暴力+二分图匹配</td>
<td>37</td>
<td>36</td>
<td>73</td>
<td>6</td>
</tr>
<tr>
<td>3171</td>
<td>费用流</td>
<td>38</td>
<td>35</td>
<td>73</td>
<td>7</td>
</tr>
<tr>
<td>3238</td>
<td>后缀数组+单调栈</td>
<td>35</td>
<td>38</td>
<td>73</td>
<td>7</td>
</tr>
<tr>
<td>3329</td>
<td>数位DP+矩阵乘法</td>
<td>36</td>
<td>37</td>
<td>73</td>
<td>5</td>
</tr>
<tr>
<td>3330</td>
<td>三分套三分</td>
<td>36</td>
<td>37</td>
<td>73</td>
<td>4</td>
</tr>
<tr>
<td>3441</td>
<td>BIT+二分</td>
<td>39</td>
<td>34</td>
<td>73</td>
<td>5</td>
</tr>
<tr>
<td>3503</td>
<td>异或高斯消元</td>
<td>39</td>
<td>34</td>
<td>73</td>
<td>7</td>
</tr>
<tr>
<td>3621</td>
<td>数学</td>
<td>38</td>
<td>35</td>
<td>73</td>
<td>2</td>
</tr>
<tr>
<td>3931</td>
<td>最短路+网络流</td>
<td>35</td>
<td>38</td>
<td>73</td>
<td>8</td>
</tr>
<tr>
<td>3998</td>
<td>后缀自动机</td>
<td>35</td>
<td>38</td>
<td>73</td>
<td>8</td>
</tr>
<tr>
<td>3999</td>
<td>树链剖分</td>
<td>32</td>
<td>41</td>
<td>73</td>
<td>6</td>
</tr>
<tr>
<td>4007</td>
<td>DP</td>
<td>37</td>
<td>36</td>
<td>73</td>
<td>7</td>
</tr>
<tr>
<td>4028</td>
<td>set+分块</td>
<td>35</td>
<td>38</td>
<td>73</td>
<td>6</td>
</tr>
<tr>
<td>4153</td>
<td>链表合并+set</td>
<td>38</td>
<td>35</td>
<td>73</td>
<td>5</td>
</tr>
<tr>
<td>4243</td>
<td>并查集统计</td>
<td>39</td>
<td>34</td>
<td>73</td>
<td></td>
</tr>
<tr>
<td>4245</td>
<td>按位线性基调整</td>
<td>40</td>
<td>33</td>
<td>73</td>
<td></td>
</tr>
<tr>
<td>1934&amp;2768</td>
<td>网络流</td>
<td>38</td>
<td>35</td>
<td>73</td>
<td>8</td>
</tr>
<tr>
<td>1014</td>
<td>Splay+二分HASH</td>
<td>34</td>
<td>40</td>
<td>74</td>
<td>8</td>
</tr>
<tr>
<td>1017</td>
<td>树形DP</td>
<td>38</td>
<td>36</td>
<td>74</td>
<td>4</td>
</tr>
<tr>
<td>1049</td>
<td>LIS+DP</td>
<td>40</td>
<td>34</td>
<td>74</td>
<td>3</td>
</tr>
<tr>
<td>1073</td>
<td>K短路</td>
<td>35</td>
<td>39</td>
<td>74</td>
<td>4</td>
</tr>
<tr>
<td>1185</td>
<td>旋转卡壳</td>
<td>36</td>
<td>38</td>
<td>74</td>
<td>8</td>
</tr>
<tr>
<td>1190</td>
<td>分层背包</td>
<td>40</td>
<td>34</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>1226</td>
<td>状压DP</td>
<td>40</td>
<td>34</td>
<td>74</td>
<td>8</td>
</tr>
<tr>
<td>1305</td>
<td>二分+网络流</td>
<td>38</td>
<td>36</td>
<td>74</td>
<td>8</td>
</tr>
<tr>
<td>1444</td>
<td>AC自动机+矩阵乘法</td>
<td>36</td>
<td>38</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>1500</td>
<td>Splay各种操作</td>
<td>33</td>
<td>41</td>
<td>74</td>
<td>10</td>
</tr>
<tr>
<td>1875</td>
<td>矩阵乘法+拆边构图</td>
<td>39</td>
<td>35</td>
<td>74</td>
<td>8</td>
</tr>
<tr>
<td>1880</td>
<td>最短路+拓扑</td>
<td>37</td>
<td>37</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>1930</td>
<td>费用流</td>
<td>40</td>
<td>34</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>1941</td>
<td>K-D树</td>
<td>33</td>
<td>41</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>2004</td>
<td>矩阵乘法</td>
<td>36</td>
<td>38</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>2121</td>
<td>DP</td>
<td>40</td>
<td>34</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>2135</td>
<td>贪心+堆</td>
<td>39</td>
<td>35</td>
<td>74</td>
<td>6</td>
</tr>
<tr>
<td>2143</td>
<td>Dijkstra堆优不建边分层图</td>
<td>35</td>
<td>39</td>
<td>74</td>
<td>5</td>
</tr>
<tr>
<td>2301</td>
<td>容斥+莫比乌斯反演+前缀和</td>
<td>38</td>
<td>36</td>
<td>74</td>
<td>8</td>
</tr>
<tr>
<td>2336</td>
<td>搜索+随机化</td>
<td>39</td>
<td>35</td>
<td>74</td>
<td>5</td>
</tr>
<tr>
<td>2342</td>
<td>Manacher+并查集</td>
<td>40</td>
<td>34</td>
<td>74</td>
<td>6</td>
</tr>
<tr>
<td>2622</td>
<td>最短路变形</td>
<td>39</td>
<td>35</td>
<td>74</td>
<td>6</td>
</tr>
<tr>
<td>2648</td>
<td>K-D树</td>
<td>33</td>
<td>41</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>2728</td>
<td>推性质+按位统计</td>
<td>41</td>
<td>33</td>
<td>74</td>
<td>6</td>
</tr>
<tr>
<td>2958</td>
<td>DP</td>
<td>42</td>
<td>32</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>3083</td>
<td>树链剖分+DFS序讨论</td>
<td>34</td>
<td>40</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>3122</td>
<td>数列求和分类讨论逆元+BSGS</td>
<td>38</td>
<td>36</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>3198</td>
<td>HASH+容斥</td>
<td>36</td>
<td>38</td>
<td>74</td>
<td>6</td>
</tr>
<tr>
<td>3294</td>
<td>DP+容斥</td>
<td>41</td>
<td>33</td>
<td>74</td>
<td>8</td>
</tr>
<tr>
<td>3534</td>
<td>矩阵树定理</td>
<td>39</td>
<td>35</td>
<td>74</td>
<td>6</td>
</tr>
<tr>
<td>3564</td>
<td>最小圆覆盖</td>
<td>34</td>
<td>40</td>
<td>74</td>
<td>3</td>
</tr>
<tr>
<td>3744</td>
<td>分块在线统计逆序对</td>
<td>35</td>
<td>39</td>
<td>74</td>
<td>8</td>
</tr>
<tr>
<td>3751</td>
<td>HASH判方程</td>
<td>40</td>
<td>34</td>
<td>74</td>
<td>8</td>
</tr>
<tr>
<td>3875</td>
<td>SPFA维护DP</td>
<td>39</td>
<td>35</td>
<td>74</td>
<td>6</td>
</tr>
<tr>
<td>3932</td>
<td>差分主席树</td>
<td>34</td>
<td>40</td>
<td>74</td>
<td>6</td>
</tr>
<tr>
<td>3938</td>
<td>离线李超线段树</td>
<td>34</td>
<td>40</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>4000</td>
<td>矩阵乘法</td>
<td>36</td>
<td>38</td>
<td>74</td>
<td>5</td>
</tr>
<tr>
<td>4010</td>
<td>拓扑+堆</td>
<td>38</td>
<td>36</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>4013</td>
<td>树形DP</td>
<td>39</td>
<td>35</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>4033</td>
<td>树形DP</td>
<td>39</td>
<td>35</td>
<td>74</td>
<td>7</td>
</tr>
<tr>
<td>4152</td>
<td>排序+最短路</td>
<td>38</td>
<td>36</td>
<td>74</td>
<td>5</td>
</tr>
<tr>
<td>4237</td>
<td>分治+统计</td>
<td>37</td>
<td>37</td>
<td>74</td>
<td></td>
</tr>
<tr>
<td>4239</td>
<td>优先队列+二分</td>
<td>38</td>
<td>36</td>
<td>74</td>
<td></td>
</tr>
<tr>
<td>4241</td>
<td>分块</td>
<td>34</td>
<td>40</td>
<td>74</td>
<td></td>
</tr>
<tr>
<td>4299</td>
<td>主席树</td>
<td>38</td>
<td>36</td>
<td>74</td>
<td>8</td>
</tr>
<tr>
<td>1001</td>
<td>平面图转对偶图+最短路</td>
<td>37</td>
<td>38</td>
<td>75</td>
<td>8</td>
</tr>
<tr>
<td>1004</td>
<td>Poyla定理+DP+逆元</td>
<td>39</td>
<td>36</td>
<td>75</td>
<td>8</td>
</tr>
<tr>
<td>1009</td>
<td>KMP+矩阵乘法</td>
<td>38</td>
<td>37</td>
<td>75</td>
<td>8</td>
</tr>
<tr>
<td>1021</td>
<td>DP+优化</td>
<td>39</td>
<td>36</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>1027</td>
<td>凸包+最短路</td>
<td>36</td>
<td>39</td>
<td>75</td>
<td>4</td>
</tr>
<tr>
<td>1067</td>
<td>线段树分类讨论</td>
<td>36</td>
<td>39</td>
<td>75</td>
<td>2</td>
</tr>
<tr>
<td>1195</td>
<td>AC自动机+状压BFS</td>
<td>37</td>
<td>38</td>
<td>75</td>
<td>4</td>
</tr>
<tr>
<td>1449</td>
<td>费用流</td>
<td>40</td>
<td>35</td>
<td>75</td>
<td>8</td>
</tr>
<tr>
<td>1453</td>
<td>线段树+并查集</td>
<td>36</td>
<td>39</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>1917</td>
<td>树形贪心</td>
<td>43</td>
<td>32</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>1924</td>
<td>tarjan</td>
<td>35</td>
<td>40</td>
<td>75</td>
<td>4</td>
</tr>
<tr>
<td>1937</td>
<td>KM</td>
<td>39</td>
<td>36</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>2119</td>
<td>分段HASH</td>
<td>40</td>
<td>35</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>2128</td>
<td>按权值分块</td>
<td>35</td>
<td>40</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>2164</td>
<td>树剖背包</td>
<td>33</td>
<td>42</td>
<td>75</td>
<td>6</td>
</tr>
<tr>
<td>2244</td>
<td>三维偏序</td>
<td>36</td>
<td>39</td>
<td>75</td>
<td>4</td>
</tr>
<tr>
<td>2303</td>
<td>并查集+讨论</td>
<td>41</td>
<td>34</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>2561</td>
<td>网络流</td>
<td>39</td>
<td>36</td>
<td>75</td>
<td>6</td>
</tr>
<tr>
<td>2744</td>
<td>转化后二分图</td>
<td>40</td>
<td>35</td>
<td>75</td>
<td>6</td>
</tr>
<tr>
<td>2746</td>
<td>AC自动机+FAIL树LCA</td>
<td>37</td>
<td>38</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>2750</td>
<td>最短路+DP</td>
<td>41</td>
<td>34</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>2956</td>
<td>推公式+分块</td>
<td>40</td>
<td>35</td>
<td>75</td>
<td>6</td>
</tr>
<tr>
<td>3091</td>
<td>LCT各种操作大力维护</td>
<td>34</td>
<td>41</td>
<td>75</td>
<td>8</td>
</tr>
<tr>
<td>3112</td>
<td>单纯形</td>
<td>36</td>
<td>39</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>3203</td>
<td>三分+单调队列</td>
<td>38</td>
<td>37</td>
<td>75</td>
<td>6</td>
</tr>
<tr>
<td>3597</td>
<td>二分+DFS找负环</td>
<td>41</td>
<td>34</td>
<td>75</td>
<td>6</td>
</tr>
<tr>
<td>3626</td>
<td>离线树链剖分</td>
<td>34</td>
<td>41</td>
<td>75</td>
<td>6</td>
</tr>
<tr>
<td>3636</td>
<td>分治+DP</td>
<td>38</td>
<td>37</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>3926</td>
<td>后缀自动机</td>
<td>37</td>
<td>38</td>
<td>75</td>
<td>8</td>
</tr>
<tr>
<td>3934</td>
<td>插头DP</td>
<td>38</td>
<td>37</td>
<td>75</td>
<td>6</td>
</tr>
<tr>
<td>3956</td>
<td>单调栈+RMQ</td>
<td>41</td>
<td>34</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>4002</td>
<td>矩阵乘法+推公式</td>
<td>41</td>
<td>34</td>
<td>75</td>
<td>5</td>
</tr>
<tr>
<td>4017</td>
<td>按位统计+树状数组</td>
<td>39</td>
<td>36</td>
<td>75</td>
<td>6</td>
</tr>
<tr>
<td>4037</td>
<td>矩阵乘法</td>
<td>38</td>
<td>37</td>
<td>75</td>
<td>5</td>
</tr>
<tr>
<td>4289</td>
<td>Dijkstra</td>
<td>39</td>
<td>36</td>
<td>75</td>
<td></td>
</tr>
<tr>
<td>4404</td>
<td>BFS+打表</td>
<td>39</td>
<td>36</td>
<td>75</td>
<td></td>
</tr>
<tr>
<td>1487&amp;4316</td>
<td>仙人掌DP</td>
<td>36</td>
<td>39</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>2109&amp;2535</td>
<td>拓扑逆向加边</td>
<td>40</td>
<td>35</td>
<td>75</td>
<td>7</td>
</tr>
<tr>
<td>1194</td>
<td>BFS+tarjan缩点最长路</td>
<td>38</td>
<td>38</td>
<td>76</td>
<td>8</td>
</tr>
<tr>
<td>1298</td>
<td>构造</td>
<td>41</td>
<td>35</td>
<td>76</td>
<td>8</td>
</tr>
<tr>
<td>1443</td>
<td>二分图+判断</td>
<td>41</td>
<td>35</td>
<td>76</td>
<td>8</td>
</tr>
<tr>
<td>1913</td>
<td>极角排序统计贡献</td>
<td>43</td>
<td>33</td>
<td>76</td>
<td>7</td>
</tr>
<tr>
<td>1997</td>
<td>2-SAT</td>
<td>40</td>
<td>36</td>
<td>76</td>
<td>4</td>
</tr>
<tr>
<td>1998</td>
<td>并查集+置换</td>
<td>40</td>
<td>36</td>
<td>76</td>
<td>7</td>
</tr>
<tr>
<td>2007</td>
<td>平面图转对偶图+最短路</td>
<td>38</td>
<td>38</td>
<td>76</td>
<td>7</td>
</tr>
<tr>
<td>2129</td>
<td>多次前缀和处理</td>
<td>40</td>
<td>36</td>
<td>76</td>
<td>5</td>
</tr>
<tr>
<td>2145</td>
<td>密码学</td>
<td>37</td>
<td>39</td>
<td>76</td>
<td>1</td>
</tr>
<tr>
<td>2553</td>
<td>AC自动机+矩阵乘法</td>
<td>37</td>
<td>39</td>
<td>76</td>
<td>7</td>
</tr>
<tr>
<td>2568</td>
<td>按位BIT</td>
<td>39</td>
<td>37</td>
<td>76</td>
<td>4</td>
</tr>
<tr>
<td>2597</td>
<td>费用流</td>
<td>42</td>
<td>34</td>
<td>76</td>
<td>7</td>
</tr>
<tr>
<td>3622</td>
<td>容斥DP</td>
<td>44</td>
<td>32</td>
<td>76</td>
<td>8</td>
</tr>
<tr>
<td>3630</td>
<td>最小割</td>
<td>37</td>
<td>39</td>
<td>76</td>
<td>7</td>
</tr>
<tr>
<td>3874</td>
<td>单调贪心+三分</td>
<td>40</td>
<td>36</td>
<td>76</td>
<td>4</td>
</tr>
<tr>
<td>3990</td>
<td>暴力</td>
<td>40</td>
<td>36</td>
<td>76</td>
<td>7</td>
</tr>
<tr>
<td>3991</td>
<td>虚树+SET</td>
<td>35</td>
<td>41</td>
<td>76</td>
<td>8</td>
</tr>
<tr>
<td>4128</td>
<td>矩阵求逆</td>
<td>38</td>
<td>38</td>
<td>76</td>
<td>4</td>
</tr>
<tr>
<td>4238</td>
<td>生成树找环讨论</td>
<td>41</td>
<td>35</td>
<td>76</td>
<td></td>
</tr>
<tr>
<td>4260</td>
<td>(可持久化)Trie树</td>
<td>36</td>
<td>40</td>
<td>76</td>
<td></td>
</tr>
<tr>
<td>4380</td>
<td>区间DP</td>
<td>40</td>
<td>36</td>
<td>76</td>
<td></td>
</tr>
<tr>
<td>4381</td>
<td>分块暴力</td>
<td>36</td>
<td>40</td>
<td>76</td>
<td></td>
</tr>
<tr>
<td>1023</td>
<td>仙人掌求直径</td>
<td>38</td>
<td>39</td>
<td>77</td>
<td>6</td>
</tr>
<tr>
<td>1178</td>
<td>线段扫描+贪心+倍增预处理</td>
<td>40</td>
<td>37</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>1199</td>
<td>K-D树</td>
<td>35</td>
<td>42</td>
<td>77</td>
<td>6</td>
</tr>
<tr>
<td>1294</td>
<td>射线法+BFS</td>
<td>40</td>
<td>37</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>1493</td>
<td>线段树染色+讨论</td>
<td>36</td>
<td>41</td>
<td>77</td>
<td>7</td>
</tr>
<tr>
<td>2003</td>
<td>搜索+剪枝</td>
<td>41</td>
<td>36</td>
<td>77</td>
<td>6</td>
</tr>
<tr>
<td>2006</td>
<td>RMQ+堆</td>
<td>39</td>
<td>38</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>2228</td>
<td>DP+单调队列</td>
<td>41</td>
<td>36</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>2436</td>
<td>DP+单调优化</td>
<td>42</td>
<td>35</td>
<td>77</td>
<td>7</td>
</tr>
<tr>
<td>2595</td>
<td>斯坦纳树</td>
<td>35</td>
<td>42</td>
<td>77</td>
<td>7</td>
</tr>
<tr>
<td>2754</td>
<td>AC自动机</td>
<td>38</td>
<td>39</td>
<td>77</td>
<td>6</td>
</tr>
<tr>
<td>2756</td>
<td>二分+网络流</td>
<td>40</td>
<td>37</td>
<td>77</td>
<td>7</td>
</tr>
<tr>
<td>2811</td>
<td>贪心</td>
<td>40</td>
<td>37</td>
<td>77</td>
<td>7</td>
</tr>
<tr>
<td>2879</td>
<td>费用流动态加边</td>
<td>41</td>
<td>36</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>3064</td>
<td>线段树</td>
<td>34</td>
<td>43</td>
<td>77</td>
<td>7</td>
</tr>
<tr>
<td>3110</td>
<td>树套树</td>
<td>35</td>
<td>42</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>3123</td>
<td>DFS序可持久化线段树启发并</td>
<td>34</td>
<td>43</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>3131</td>
<td>数位DP+堆</td>
<td>39</td>
<td>38</td>
<td>77</td>
<td>7</td>
</tr>
<tr>
<td>3168</td>
<td>高斯求逆+二分图匹配</td>
<td>40</td>
<td>37</td>
<td>77</td>
<td>6</td>
</tr>
<tr>
<td>3243</td>
<td>随机化构造</td>
<td>40</td>
<td>37</td>
<td>77</td>
<td>2</td>
</tr>
<tr>
<td>3244</td>
<td>DFS序+统计答案</td>
<td>45</td>
<td>32</td>
<td>77</td>
<td>6</td>
</tr>
<tr>
<td>3438</td>
<td>最小割</td>
<td>42</td>
<td>35</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>3439</td>
<td>Trie+DFS序主席树</td>
<td>36</td>
<td>41</td>
<td>77</td>
<td>7</td>
</tr>
<tr>
<td>3504</td>
<td>网络流</td>
<td>41</td>
<td>36</td>
<td>77</td>
<td>5</td>
</tr>
<tr>
<td>3527</td>
<td>FFT</td>
<td>37</td>
<td>40</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>3641</td>
<td>环套树剖分</td>
<td>35</td>
<td>42</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>3669</td>
<td>LCT维护MST</td>
<td>36</td>
<td>41</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>4011</td>
<td>朱刘算法推论+树形DP</td>
<td>43</td>
<td>34</td>
<td>77</td>
<td>7</td>
</tr>
<tr>
<td>4026</td>
<td>主席树</td>
<td>37</td>
<td>40</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>4151</td>
<td>树上DFS</td>
<td>44</td>
<td>33</td>
<td>77</td>
<td>7</td>
</tr>
<tr>
<td>4199</td>
<td>后缀树DP</td>
<td>37</td>
<td>40</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>4346</td>
<td>树形DP</td>
<td>39</td>
<td>38</td>
<td>77</td>
<td></td>
</tr>
<tr>
<td>4377</td>
<td>扫描处理范围</td>
<td>39</td>
<td>38</td>
<td>77</td>
<td></td>
</tr>
<tr>
<td>1038</td>
<td>模拟退火</td>
<td>39</td>
<td>39</td>
<td>78</td>
<td>5</td>
</tr>
<tr>
<td>1074</td>
<td>计算几何</td>
<td>38</td>
<td>40</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>1095</td>
<td>动态树分治</td>
<td>37</td>
<td>41</td>
<td>78</td>
<td>9</td>
</tr>
<tr>
<td>1187</td>
<td>插头DP</td>
<td>37</td>
<td>41</td>
<td>78</td>
<td>8</td>
</tr>
<tr>
<td>1210</td>
<td>插头DP</td>
<td>37</td>
<td>41</td>
<td>78</td>
<td>1</td>
</tr>
<tr>
<td>1502</td>
<td>辛普森积分</td>
<td>38</td>
<td>40</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>1559</td>
<td>AC自动机DP+暴力</td>
<td>37</td>
<td>41</td>
<td>78</td>
<td>3</td>
</tr>
<tr>
<td>1791</td>
<td>基环树找直径</td>
<td>37</td>
<td>41</td>
<td>78</td>
<td>8</td>
</tr>
<tr>
<td>1972</td>
<td>暴力</td>
<td>29</td>
<td>49</td>
<td>78</td>
<td>2</td>
</tr>
<tr>
<td>2127</td>
<td>最小割</td>
<td>42</td>
<td>36</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>2132</td>
<td>网络流</td>
<td>42</td>
<td>36</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>2139</td>
<td>贪心+最小生成树</td>
<td>46</td>
<td>32</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>2140</td>
<td>Trie+tarjan</td>
<td>42</td>
<td>36</td>
<td>78</td>
<td>8</td>
</tr>
<tr>
<td>2154</td>
<td>莫比乌斯反演</td>
<td>42</td>
<td>36</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>2229</td>
<td>分治+最小割</td>
<td>39</td>
<td>39</td>
<td>78</td>
<td>6</td>
</tr>
<tr>
<td>2286</td>
<td>虚树DP</td>
<td>37</td>
<td>41</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>2333</td>
<td>可并堆套可并堆</td>
<td>36</td>
<td>42</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>2428</td>
<td>模拟退火</td>
<td>41</td>
<td>37</td>
<td>78</td>
<td>5</td>
</tr>
<tr>
<td>2539</td>
<td>KM</td>
<td>37</td>
<td>41</td>
<td>78</td>
<td>3</td>
</tr>
<tr>
<td>2564</td>
<td>凸包</td>
<td>43</td>
<td>35</td>
<td>78</td>
<td>4</td>
</tr>
<tr>
<td>2594</td>
<td>离线LCT维护动态MST</td>
<td>36</td>
<td>42</td>
<td>78</td>
<td>8</td>
</tr>
<tr>
<td>2730</td>
<td>双联通分量</td>
<td>40</td>
<td>38</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>3125</td>
<td>插头DP</td>
<td>37</td>
<td>41</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>3129</td>
<td>扩展lucas+容斥</td>
<td>38</td>
<td>40</td>
<td>78</td>
<td>8</td>
</tr>
<tr>
<td>3158</td>
<td>网络流</td>
<td>42</td>
<td>36</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>3196</td>
<td>树套树</td>
<td>32</td>
<td>46</td>
<td>78</td>
<td>9</td>
</tr>
<tr>
<td>3241</td>
<td>分类讨论DP</td>
<td>39</td>
<td>39</td>
<td>78</td>
<td>2</td>
</tr>
<tr>
<td>3246</td>
<td>树形DP</td>
<td>40</td>
<td>38</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>3530</td>
<td>AC自动机+数位DP</td>
<td>39</td>
<td>39</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>3577</td>
<td>网络流RMQ构图</td>
<td>40</td>
<td>38</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>3619</td>
<td>BFS构造+暴力</td>
<td>37</td>
<td>41</td>
<td>78</td>
<td>8</td>
</tr>
<tr>
<td>3678</td>
<td>Splay</td>
<td>35</td>
<td>43</td>
<td>78</td>
<td>6</td>
</tr>
<tr>
<td>4006</td>
<td>斯坦纳树</td>
<td>35</td>
<td>43</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>4035</td>
<td>博弈</td>
<td>45</td>
<td>33</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>4313</td>
<td>DP</td>
<td>43</td>
<td>35</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>4373</td>
<td>线段树</td>
<td>40</td>
<td>38</td>
<td>78</td>
<td></td>
</tr>
<tr>
<td>4399</td>
<td>线段树合并</td>
<td>35</td>
<td>43</td>
<td>78</td>
<td></td>
</tr>
<tr>
<td>1999&amp;2282</td>
<td>树上DFS+单调队列</td>
<td>40</td>
<td>38</td>
<td>78</td>
<td>7</td>
</tr>
<tr>
<td>3157&amp;3516</td>
<td>数学</td>
<td>45</td>
<td>33</td>
<td>78</td>
<td>6</td>
</tr>
<tr>
<td>1011</td>
<td>乱搞</td>
<td>49</td>
<td>30</td>
<td>79</td>
<td>2</td>
</tr>
<tr>
<td>1064</td>
<td>图论分类讨论</td>
<td>43</td>
<td>36</td>
<td>79</td>
<td>8</td>
</tr>
<tr>
<td>1494</td>
<td>最小表示法+矩阵乘法</td>
<td>38</td>
<td>41</td>
<td>79</td>
<td>7</td>
</tr>
<tr>
<td>1495</td>
<td>树形DP</td>
<td>41</td>
<td>38</td>
<td>79</td>
<td>7</td>
</tr>
<tr>
<td>1565</td>
<td>拓扑+最小割</td>
<td>42</td>
<td>37</td>
<td>79</td>
<td>8</td>
</tr>
<tr>
<td>1969</td>
<td>LCT维护边双</td>
<td>37</td>
<td>42</td>
<td>79</td>
<td>7</td>
</tr>
<tr>
<td>2137</td>
<td>分类讨论+求K次幂前缀和</td>
<td>39</td>
<td>40</td>
<td>79</td>
<td>6</td>
</tr>
<tr>
<td>2170</td>
<td>插头DP</td>
<td>38</td>
<td>41</td>
<td>79</td>
<td>7</td>
</tr>
<tr>
<td>2324</td>
<td>Floyd+费用流</td>
<td>42</td>
<td>37</td>
<td>79</td>
<td>8</td>
</tr>
<tr>
<td>2437</td>
<td>二分图+判断</td>
<td>43</td>
<td>36</td>
<td>79</td>
<td>8</td>
</tr>
<tr>
<td>2668</td>
<td>费用流</td>
<td>44</td>
<td>35</td>
<td>79</td>
<td>8</td>
</tr>
<tr>
<td>2669</td>
<td>DP+搜索容斥</td>
<td>42</td>
<td>37</td>
<td>79</td>
<td>6</td>
</tr>
<tr>
<td>2876</td>
<td>二分+数学</td>
<td>46</td>
<td>33</td>
<td>79</td>
<td>5</td>
</tr>
<tr>
<td>3242</td>
<td>环套树DP</td>
<td>38</td>
<td>41</td>
<td>79</td>
<td>7</td>
</tr>
<tr>
<td>3571</td>
<td>分治+KM</td>
<td>40</td>
<td>39</td>
<td>79</td>
<td>6</td>
</tr>
<tr>
<td>3611</td>
<td>虚树DP</td>
<td>37</td>
<td>42</td>
<td>79</td>
<td>8</td>
</tr>
<tr>
<td>3873</td>
<td>悬线法+根号分类讨论</td>
<td>39</td>
<td>40</td>
<td>79</td>
<td>6</td>
</tr>
<tr>
<td>3876</td>
<td>费用流</td>
<td>43</td>
<td>36</td>
<td>79</td>
<td>7</td>
</tr>
<tr>
<td>3935</td>
<td>单纯形</td>
<td>40</td>
<td>39</td>
<td>79</td>
<td>6</td>
</tr>
<tr>
<td>4005</td>
<td>数形结合</td>
<td>47</td>
<td>32</td>
<td>79</td>
<td>6</td>
</tr>
<tr>
<td>4336</td>
<td>树剖套set</td>
<td>33</td>
<td>46</td>
<td>79</td>
<td>6</td>
</tr>
<tr>
<td>4345</td>
<td>堆</td>
<td>41</td>
<td>38</td>
<td>79</td>
<td></td>
</tr>
<tr>
<td>4358</td>
<td>分块+并查集</td>
<td>40</td>
<td>39</td>
<td>79</td>
<td></td>
</tr>
<tr>
<td>4361</td>
<td>DP+BIT优化+容斥</td>
<td>45</td>
<td>34</td>
<td>79</td>
<td></td>
</tr>
<tr>
<td>1018</td>
<td>线段树维护连通性+大力讨论</td>
<td>37</td>
<td>43</td>
<td>80</td>
<td>8</td>
</tr>
<tr>
<td>1492</td>
<td>CDQ分治优化DP</td>
<td>40</td>
<td>40</td>
<td>80</td>
<td>8</td>
</tr>
<tr>
<td>1926</td>
<td>分块+莫队</td>
<td>36</td>
<td>44</td>
<td>80</td>
<td>7</td>
</tr>
<tr>
<td>2000</td>
<td>双端链表</td>
<td>44</td>
<td>36</td>
<td>80</td>
<td>8</td>
</tr>
<tr>
<td>2034</td>
<td>贪心调整</td>
<td>47</td>
<td>33</td>
<td>80</td>
<td>7</td>
</tr>
<tr>
<td>2159</td>
<td>二项式定理斯特林+树DP</td>
<td>45</td>
<td>35</td>
<td>80</td>
<td>7</td>
</tr>
<tr>
<td>2441</td>
<td>BIT+扫描线</td>
<td>40</td>
<td>40</td>
<td>80</td>
<td>3</td>
</tr>
<tr>
<td>2547</td>
<td>二分BFS+匈牙利</td>
<td>41</td>
<td>39</td>
<td>80</td>
<td>6</td>
</tr>
<tr>
<td>2707</td>
<td>tarjan+期望高斯</td>
<td>40</td>
<td>40</td>
<td>80</td>
<td>8</td>
</tr>
<tr>
<td>2734</td>
<td>状压DP</td>
<td>47</td>
<td>33</td>
<td>80</td>
<td>7</td>
</tr>
<tr>
<td>2741</td>
<td>分块+可持久化Trie</td>
<td>38</td>
<td>42</td>
<td>80</td>
<td>7</td>
</tr>
<tr>
<td>3513</td>
<td>FFT</td>
<td>40</td>
<td>40</td>
<td>80</td>
<td>8</td>
</tr>
<tr>
<td>3533</td>
<td>线段树+凸壳三分</td>
<td>37</td>
<td>43</td>
<td>80</td>
<td>6</td>
</tr>
<tr>
<td>3561</td>
<td>莫比乌斯反演</td>
<td>44</td>
<td>36</td>
<td>80</td>
<td>8</td>
</tr>
<tr>
<td>3720</td>
<td>块状树</td>
<td>37</td>
<td>43</td>
<td>80</td>
<td>7</td>
</tr>
<tr>
<td>3743</td>
<td>树形DP</td>
<td>38</td>
<td>42</td>
<td>80</td>
<td>7</td>
</tr>
<tr>
<td>4025</td>
<td>LCT维护二分图</td>
<td>37</td>
<td>43</td>
<td>80</td>
<td>7</td>
</tr>
<tr>
<td>4032</td>
<td>后缀自动机+序列自动机+BFS</td>
<td>40</td>
<td>40</td>
<td>80</td>
<td>7</td>
</tr>
<tr>
<td>4154</td>
<td>K-D树</td>
<td>37</td>
<td>43</td>
<td>80</td>
<td>8</td>
</tr>
<tr>
<td>4155</td>
<td>网络流+bitset压位DP</td>
<td>40</td>
<td>40</td>
<td>80</td>
<td>5</td>
</tr>
<tr>
<td>4242</td>
<td>BFS建图+货车运输</td>
<td>39</td>
<td>41</td>
<td>80</td>
<td>8</td>
</tr>
<tr>
<td>4317</td>
<td>动态树分治</td>
<td>37</td>
<td>43</td>
<td>80</td>
<td>6</td>
</tr>
<tr>
<td>4386</td>
<td>矩阵乘法</td>
<td>41</td>
<td>39</td>
<td>80</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p><br><br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>题号</th>
<th>算法</th>
<th>思想难度</th>
<th>实现难度</th>
<th>总难度</th>
<th>推荐指数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1033</td>
<td>模拟</td>
<td>31</td>
<td>50</td>
<td>81</td>
<td>8</td>
</tr>
<tr>
<td>1094</td>
<td>计算几何</td>
<td>39</td>
<td>42</td>
<td>81</td>
<td>7</td>
</tr>
<tr>
<td>1200</td>
<td>贪心+DP</td>
<td>47</td>
<td>34</td>
<td>81</td>
<td>8</td>
</tr>
<tr>
<td>2039</td>
<td>最小割</td>
<td>44</td>
<td>37</td>
<td>81</td>
<td>7</td>
</tr>
<tr>
<td>2331</td>
<td>插头DP</td>
<td>39</td>
<td>42</td>
<td>81</td>
<td>5</td>
</tr>
<tr>
<td>2433</td>
<td>计算几何+最短路</td>
<td>43</td>
<td>38</td>
<td>81</td>
<td>7</td>
</tr>
<tr>
<td>2459</td>
<td>线段树维护连通性+大力讨论</td>
<td>37</td>
<td>44</td>
<td>81</td>
<td>7</td>
</tr>
<tr>
<td>2548</td>
<td>暴力模拟</td>
<td>30</td>
<td>51</td>
<td>81</td>
<td>7</td>
</tr>
<tr>
<td>2726</td>
<td>CDQ分治优化DP</td>
<td>41</td>
<td>40</td>
<td>81</td>
<td>6</td>
</tr>
<tr>
<td>2806</td>
<td>广义后缀自动机+DP单调优化</td>
<td>41</td>
<td>40</td>
<td>81</td>
<td>8</td>
</tr>
<tr>
<td>3309</td>
<td>莫比乌斯反演+推性质</td>
<td>44</td>
<td>37</td>
<td>81</td>
<td>7</td>
</tr>
<tr>
<td>3677</td>
<td>树形DP</td>
<td>43</td>
<td>38</td>
<td>81</td>
<td>6</td>
</tr>
<tr>
<td>3786</td>
<td>Splay维护括号序列</td>
<td>38</td>
<td>43</td>
<td>81</td>
<td>6</td>
</tr>
<tr>
<td>3811</td>
<td>线性基+暴力</td>
<td>44</td>
<td>37</td>
<td>81</td>
<td>7</td>
</tr>
<tr>
<td>3925</td>
<td>子集DP</td>
<td>46</td>
<td>35</td>
<td>81</td>
<td>8</td>
</tr>
<tr>
<td>4016</td>
<td>Dijkstra+树分治</td>
<td>37</td>
<td>44</td>
<td>81</td>
<td>5</td>
</tr>
<tr>
<td>4036</td>
<td>反演子集求概率</td>
<td>50</td>
<td>31</td>
<td>81</td>
<td>7</td>
</tr>
<tr>
<td>4180</td>
<td>后缀自动机+倍增DP</td>
<td>41</td>
<td>40</td>
<td>81</td>
<td>6</td>
</tr>
<tr>
<td>4311</td>
<td>分治线段树挂链+凸壳三分</td>
<td>38</td>
<td>43</td>
<td>81</td>
<td>8</td>
</tr>
<tr>
<td>4372</td>
<td>动态树分治+BIT</td>
<td>37</td>
<td>44</td>
<td>81</td>
<td>6</td>
</tr>
<tr>
<td>4383</td>
<td>线段树挂链</td>
<td>39</td>
<td>42</td>
<td>81</td>
<td></td>
</tr>
<tr>
<td>2961&amp;4140</td>
<td>二进制分组+凸壳三分</td>
<td>39</td>
<td>42</td>
<td>81</td>
<td>8</td>
</tr>
<tr>
<td>1758</td>
<td>树分治+二分+单调队列</td>
<td>39</td>
<td>43</td>
<td>82</td>
<td>8</td>
</tr>
<tr>
<td>1797</td>
<td>最小割+tarjan判断</td>
<td>43</td>
<td>39</td>
<td>82</td>
<td>7</td>
</tr>
<tr>
<td>1835</td>
<td>线段树优化DP</td>
<td>43</td>
<td>39</td>
<td>82</td>
<td>8</td>
</tr>
<tr>
<td>2125</td>
<td>静态仙人掌</td>
<td>39</td>
<td>43</td>
<td>82</td>
<td>7</td>
</tr>
<tr>
<td>2780</td>
<td>广义后缀自动机+离线BIT</td>
<td>40</td>
<td>42</td>
<td>82</td>
<td>8</td>
</tr>
<tr>
<td>2960</td>
<td>平面图转对偶图+最小树形图</td>
<td>36</td>
<td>46</td>
<td>82</td>
<td>7</td>
</tr>
<tr>
<td>3232</td>
<td>二分+网络流</td>
<td>45</td>
<td>37</td>
<td>82</td>
<td>7</td>
</tr>
<tr>
<td>3529</td>
<td>莫比乌斯反演+离线树状数组</td>
<td>43</td>
<td>39</td>
<td>82</td>
<td>8</td>
</tr>
<tr>
<td>3532</td>
<td>网络流</td>
<td>44</td>
<td>38</td>
<td>82</td>
<td>8</td>
</tr>
<tr>
<td>3879</td>
<td>后缀树+虚树</td>
<td>36</td>
<td>46</td>
<td>82</td>
<td>6</td>
</tr>
<tr>
<td>4129</td>
<td>树上带修莫队+权值分块</td>
<td>38</td>
<td>44</td>
<td>82</td>
<td>8</td>
</tr>
<tr>
<td>4197</td>
<td>状压DP</td>
<td>45</td>
<td>37</td>
<td>82</td>
<td>8</td>
</tr>
<tr>
<td>4246</td>
<td>极角排序扫描统计贡献</td>
<td>45</td>
<td>37</td>
<td>82</td>
<td></td>
</tr>
<tr>
<td>4310</td>
<td>二分+后缀树</td>
<td>40</td>
<td>42</td>
<td>82</td>
<td>7</td>
</tr>
<tr>
<td>4384</td>
<td>乱搞+Cheat</td>
<td>45</td>
<td>37</td>
<td>82</td>
<td></td>
</tr>
<tr>
<td>1974</td>
<td>转化后DP</td>
<td>46</td>
<td>37</td>
<td>83</td>
<td>8</td>
</tr>
<tr>
<td>2001</td>
<td>动态MST</td>
<td>40</td>
<td>43</td>
<td>83</td>
<td>8</td>
</tr>
<tr>
<td>2126</td>
<td>转化后状压矩乘</td>
<td>45</td>
<td>38</td>
<td>83</td>
<td>8</td>
</tr>
<tr>
<td>2671</td>
<td>莫比乌斯反演</td>
<td>47</td>
<td>36</td>
<td>83</td>
<td>6</td>
</tr>
<tr>
<td>2959</td>
<td>LCT维护边双</td>
<td>39</td>
<td>44</td>
<td>83</td>
<td>8</td>
</tr>
<tr>
<td>3218</td>
<td>主席树优化网络流</td>
<td>42</td>
<td>41</td>
<td>83</td>
<td>8</td>
</tr>
<tr>
<td>3229</td>
<td>石子合并加强</td>
<td>48</td>
<td>35</td>
<td>83</td>
<td>3</td>
</tr>
<tr>
<td>3482</td>
<td>分层图最短路+单调统计</td>
<td>42</td>
<td>41</td>
<td>83</td>
<td>8</td>
</tr>
<tr>
<td>3994</td>
<td>莫比乌斯反演</td>
<td>46</td>
<td>37</td>
<td>83</td>
<td>7</td>
</tr>
<tr>
<td>3995</td>
<td>线段树维护连通性</td>
<td>38</td>
<td>45</td>
<td>83</td>
<td>7</td>
</tr>
<tr>
<td>4092</td>
<td>DP</td>
<td>47</td>
<td>36</td>
<td>83</td>
<td>8</td>
</tr>
<tr>
<td>2209&amp;2329</td>
<td>Splay大力维护</td>
<td>39</td>
<td>44</td>
<td>83</td>
<td>8</td>
</tr>
<tr>
<td>1558</td>
<td>线段树大力维护</td>
<td>41</td>
<td>43</td>
<td>84</td>
<td>8</td>
</tr>
<tr>
<td>2434</td>
<td>AC自动机+FAIL树状数组</td>
<td>43</td>
<td>41</td>
<td>84</td>
<td>8</td>
</tr>
<tr>
<td>2878</td>
<td>基环树DP</td>
<td>41</td>
<td>43</td>
<td>84</td>
<td>7</td>
</tr>
<tr>
<td>3160</td>
<td>FFT+Manacher</td>
<td>42</td>
<td>42</td>
<td>84</td>
<td>8</td>
</tr>
<tr>
<td>3637</td>
<td>有向LCT维护虚边</td>
<td>40</td>
<td>44</td>
<td>84</td>
<td>8</td>
</tr>
<tr>
<td>3672</td>
<td>树剖+凸壳三分</td>
<td>39</td>
<td>45</td>
<td>84</td>
<td>8</td>
</tr>
<tr>
<td>3681</td>
<td>主席树合并优化网络流</td>
<td>43</td>
<td>41</td>
<td>84</td>
<td>8</td>
</tr>
<tr>
<td>3730</td>
<td>动态树分治+动态开点线段树</td>
<td>38</td>
<td>46</td>
<td>84</td>
<td>7</td>
</tr>
<tr>
<td>3745</td>
<td>单调队列+线段树大力维护</td>
<td>40</td>
<td>44</td>
<td>84</td>
<td>7</td>
</tr>
<tr>
<td>4134</td>
<td>博弈+Trie合并</td>
<td>44</td>
<td>40</td>
<td>84</td>
<td>7</td>
</tr>
<tr>
<td>4367</td>
<td>主席树</td>
<td>42</td>
<td>42</td>
<td>84</td>
<td>8</td>
</tr>
<tr>
<td>4389</td>
<td>LCT维护虚边</td>
<td>38</td>
<td>46</td>
<td>84</td>
<td>8</td>
</tr>
<tr>
<td>4402</td>
<td>计数</td>
<td>45</td>
<td>39</td>
<td>84</td>
<td></td>
</tr>
<tr>
<td>2613</td>
<td>置换+构造</td>
<td>46</td>
<td>39</td>
<td>85</td>
<td>6</td>
</tr>
<tr>
<td>2651</td>
<td>树形DP</td>
<td>40</td>
<td>45</td>
<td>85</td>
<td>7</td>
</tr>
<tr>
<td>2815</td>
<td>LCA重构树</td>
<td>47</td>
<td>38</td>
<td>85</td>
<td>7</td>
</tr>
<tr>
<td>3514</td>
<td>LCT维护MST+主席树</td>
<td>40</td>
<td>45</td>
<td>85</td>
<td>8</td>
</tr>
<tr>
<td>3591</td>
<td>状压DP</td>
<td>50</td>
<td>35</td>
<td>85</td>
<td>8</td>
</tr>
<tr>
<td>3616</td>
<td>K-D树+BITSET</td>
<td>41</td>
<td>44</td>
<td>85</td>
<td>8</td>
</tr>
<tr>
<td>3640</td>
<td>高斯求逆优化</td>
<td>48</td>
<td>37</td>
<td>85</td>
<td>8</td>
</tr>
<tr>
<td>3817</td>
<td>类欧几里得</td>
<td>50</td>
<td>35</td>
<td>85</td>
<td>6</td>
</tr>
<tr>
<td>4066</td>
<td>K-D树+重建</td>
<td>37</td>
<td>48</td>
<td>85</td>
<td>8</td>
</tr>
<tr>
<td>1065</td>
<td>环套树DP</td>
<td>48</td>
<td>38</td>
<td>86</td>
<td>8</td>
</tr>
<tr>
<td>2555</td>
<td>后缀自动机+LCT</td>
<td>38</td>
<td>48</td>
<td>86</td>
<td>8</td>
</tr>
<tr>
<td>3519</td>
<td>Set大力维护</td>
<td>36</td>
<td>50</td>
<td>86</td>
<td>8</td>
</tr>
<tr>
<td>3572</td>
<td>虚树</td>
<td>39</td>
<td>47</td>
<td>86</td>
<td>8</td>
</tr>
<tr>
<td>3812</td>
<td>DP+容斥</td>
<td>50</td>
<td>36</td>
<td>86</td>
<td>7</td>
</tr>
<tr>
<td>3992</td>
<td>NTT+DP快速幂优化</td>
<td>45</td>
<td>41</td>
<td>86</td>
<td>8</td>
</tr>
<tr>
<td>4379</td>
<td>树形DP</td>
<td>40</td>
<td>46</td>
<td>86</td>
<td></td>
</tr>
<tr>
<td>1414</td>
<td>Manacher+RMQ+单调队列</td>
<td>46</td>
<td>41</td>
<td>87</td>
<td>8</td>
</tr>
<tr>
<td>2040</td>
<td>树剖+线段树模拟费用流</td>
<td>39</td>
<td>48</td>
<td>87</td>
<td>7</td>
</tr>
<tr>
<td>3461</td>
<td>CDQ分治优化DP</td>
<td>46</td>
<td>41</td>
<td>87</td>
<td>8</td>
</tr>
<tr>
<td>3489</td>
<td>三维K-D树</td>
<td>43</td>
<td>44</td>
<td>87</td>
<td>8</td>
</tr>
<tr>
<td>3639</td>
<td>有向LCT维护虚边</td>
<td>41</td>
<td>46</td>
<td>87</td>
<td>8</td>
</tr>
<tr>
<td>4012</td>
<td>可持久化树链剖分</td>
<td>40</td>
<td>47</td>
<td>87</td>
<td>8</td>
</tr>
<tr>
<td>3237&amp;3563&amp;3569</td>
<td>随机化造树+线性基</td>
<td>50</td>
<td>37</td>
<td>87</td>
<td>8</td>
</tr>
<tr>
<td>3065</td>
<td>替罪羊树套权值线段树</td>
<td>39</td>
<td>49</td>
<td>88</td>
<td>9</td>
</tr>
<tr>
<td>3413</td>
<td>后缀树+主席树</td>
<td>42</td>
<td>46</td>
<td>88</td>
<td>8</td>
</tr>
<tr>
<td>3512</td>
<td>杜教筛+莫比乌斯反演</td>
<td>51</td>
<td>37</td>
<td>88</td>
<td>8</td>
</tr>
<tr>
<td>3600</td>
<td>替罪羊树+线段树</td>
<td>46</td>
<td>42</td>
<td>88</td>
<td>8</td>
</tr>
<tr>
<td>4545</td>
<td>后缀自动机+LCT</td>
<td>39</td>
<td>49</td>
<td>88</td>
<td>8</td>
</tr>
<tr>
<td>1062</td>
<td>树状数组</td>
<td>51</td>
<td>38</td>
<td>89</td>
<td>8</td>
</tr>
<tr>
<td>2144</td>
<td>转化为LCA后二分+快速统计</td>
<td>53</td>
<td>36</td>
<td>89</td>
<td>8</td>
</tr>
<tr>
<td>2149</td>
<td>CDQ分治优化DP</td>
<td>46</td>
<td>43</td>
<td>89</td>
<td>8</td>
</tr>
<tr>
<td>2653</td>
<td>按值建主席树</td>
<td>43</td>
<td>46</td>
<td>89</td>
<td>8</td>
</tr>
<tr>
<td>3551</td>
<td>Kruskal重构树+DFS序主席树</td>
<td>49</td>
<td>40</td>
<td>89</td>
<td>8</td>
</tr>
<tr>
<td>4382</td>
<td>HASH+单调扫描</td>
<td>50</td>
<td>39</td>
<td>89</td>
<td></td>
</tr>
<tr>
<td>2162</td>
<td>转化后网络流+容斥DP</td>
<td>51</td>
<td>39</td>
<td>90</td>
<td>8</td>
</tr>
<tr>
<td>3814</td>
<td>插头DP</td>
<td>41</td>
<td>49</td>
<td>90</td>
<td>7</td>
</tr>
<tr>
<td>1020</td>
<td>迭代法+射线法+点到线段距离</td>
<td>43</td>
<td>48</td>
<td>91</td>
<td>8</td>
</tr>
<tr>
<td>4348</td>
<td>暴力</td>
<td>41</td>
<td>50</td>
<td>91</td>
<td>8</td>
</tr>
<tr>
<td>2566</td>
<td>动态树分治+map套set</td>
<td>41</td>
<td>51</td>
<td>92</td>
<td>7</td>
</tr>
<tr>
<td>2965</td>
<td>平面图转对偶图+枚举+最小割</td>
<td>43</td>
<td>51</td>
<td>94</td>
<td>8</td>
</tr>
<tr>
<td>2658</td>
<td>fhqtreap</td>
<td>52</td>
<td>43</td>
<td>95</td>
<td>8</td>
</tr>
<tr>
<td>2759</td>
<td>LCT维护环套树大力讨论</td>
<td>48</td>
<td>48</td>
<td>96</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p><br>
<br></p>
<p><strong>转自<a href="http://lbn187.is-programmer.com/2015/5/16/bzoj.93165.html" target="_blank" rel="external">BZOJ刷题记录</a></strong></p>
]]></content>
      
        <categories>
            
            <category> BZOJ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 题目列表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最长上升子序列]]></title>
      <url>/2017/10/16/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<p><strong> 最长上升子序列（longest increasing subsequence） </strong>，是动态规划中一个经典的问题。<br>定义如下：对于一个序列$A_1 \cdots A_i \cdots A_n$，子序列$A_{b_1} \cdots A_{b_i} \cdots A_{b_len}$满足：$B_i \lt B_{i+1} \ (foreach \  1 \le i \lt len)$，$A_{B_i} \lt A_{B_{i+1}} \ (foreach \  1 \le i \lt len)$，且$len$最大，则子序列$A_{b_1} \cdots A_{b_i} \cdots A_{b_len}$是序列$A_1 \cdots A_i \cdots A_n$的最长上升子序列。</p>
<ol>
<li><p>第一种DP，$f[i]$代表$i$作为子序列的最后一个元素的最长上升子序列长度。$f[i]$转移的话可以枚举它前面的那个元素，所以有以下转移：$f[i] = max{f[j] + 1} \  (1 \le j \lt i \ \&amp; \&amp; \  a[i] \lt a[j])$。这个DP是状态一维，转移一维的，所以时间复杂度为$O(n^2)$。<br>对于这种DP，还可以用数据结构优化，平衡树或者离散+线段树（或树状数组），优化后的时间复杂度都是$O(nlog_{2}n)$。<br>关于方案的话，只要记录$pre[i]$为$i$从前面转移过来的位置。</p>
</li>
<li><p>第二种DP，$c[i]$代表上升子序列长度为$i$时，最后一个元素的最小值，$len$为最长上升子序列长度。考虑一个个把原序列的元素加入，对于当前的第$i$个元素，在之前的状态下找到一个最大的$j$，满足$c[j - 1] &lt; a[i] \  (1 \le j \  \&amp; \&amp; \  j \le len + 1)$，以它为最后一个元素的最长上升子序列就是以第$j$个元素为最后一个元素的最长上升子序列加上当前的第$i$个元素。因为随着上升子序列的变长，它的最后一个元素的值会越来越大，所以$c$数组是单调的，所以$j = lower \underline{} bound(c + 1, c + len + 1, a[i])$。<br>关于方案的话，$c[j - 1]$在原序列的位置就是$pre[i]$。</p>
</li>
</ol>
<p>最长下降子序列，最长不上升子序列，最长下降子序列也类似可求。</p>
<p>以下是最长上升子序列。<br>$a$数组是原序列，$n$是序列长度，$c$是辅助数组。</p>
<pre><code class="lang-cpp">int LIS(int *a, int n, int *c) {
    int len = 0;
    for (int i = 1; i &lt;= n; ++i) {
        int j = lower_bound(c + 1, c + len + 1, a[i]) - c;
        c[j] = a[i];
        if (len &lt; j) len = j;
    }
    return len;
}
</code></pre>
<p><br>
<br></p>
<h1 id="合唱队形"><a href="#合唱队形" class="headerlink" title="合唱队形"></a><a href="https://www.luogu.org/problem/show?pid=1091" target="_blank" rel="external">合唱队形</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title=" 题目描述 "></a><strong> 题目描述 </strong></h2><blockquote>
<p>$n$位同学站成一排，音乐老师要请其中的$(n - k)$位同学出列，使得剩下的K位同学排成合唱队形。<br>合唱队形是指这样的一种队形：设$k$位同学从左到右依次编号为$1, 2, \cdots , k$，他们的身高分别为$t_1, t_2, \cdots , t_k$， 则他们的身高满足$t_1 \lt \cdots \lt t_i \gt t_{i+1} \gt \cdots \gt t_k \  (1 \le i \le k)$。<br>你的任务是，已知所有$n$位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p>
</blockquote>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title=" 输入格式 "></a><strong> 输入格式 </strong></h2><blockquote>
<p>输入第一行是一个整数$n$，表示同学的总数。第一行有$n$个整数，用空格分隔，第i个整数$t_i \  (130 \le t_i \le 230)$是第$i$位同学的身高。</p>
</blockquote>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title=" 输出格式 "></a><strong> 输出格式 </strong></h2><blockquote>
<p>输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p>
</blockquote>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title=" 输入样例 "></a><strong> 输入样例 </strong></h2><blockquote>
<p>8<br>186 186 150 200 160 130 197 220</p>
</blockquote>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title=" 输出样例 "></a><strong> 输出样例 </strong></h2><blockquote>
<p>4</p>
</blockquote>
<h2 id="说明"><a href="#说明" class="headerlink" title=" 说明 "></a><strong> 说明 </strong></h2><blockquote>
<p>对于50％的数据，保证有$n \le 20$；<br>对于全部的数据，保证有$n \le 100$。</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title=" 题解 "></a><strong> 题解 </strong></h2><blockquote>
<p>为了让更少的同学出列，应计算出最长的合唱队形。<br>分别从前往后和从后往前做两遍最长上升子序列，算出每个同学作为最后一个元素的最长上升子序列$f[i]$和第一个元素的最长下降子序列$g[i]$，那么第$i$个同学作为中间最高的最长合唱队形的长度为$f[i] + g[i] - 1$。<br>因为本题数据范围很小，上述所以方法都可以过。<br>时间复杂度为$n^2$或$O(nlog_{2}n)$。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title=" 代码 "></a><strong> 代码 </strong></h2><pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

const int N = 110;

int n;
int t[N], f[N], g[N];

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, &amp;t[i]);
    for (int i = 1; i &lt;= n; ++i) {
        f[i] = 1;
        for (int j = 1; j &lt; i; ++j)
            if (t[j] &lt; t[i] &amp;&amp; f[j] &gt;= f[i]) f[i] = f[j] + 1;
    }
    for (int i = n; i &gt;= 1; --i) {
        g[i] = 1;
        for (int j = n; j &gt; i; --j)
            if (t[i] &gt; t[j] &amp;&amp; g[j] &gt;= g[i]) g[i] = g[j] + 1;
    }
    int res = 0;
    for (int i = 1; i &lt;= n; ++i)
        if (res &lt; f[i] + g[i] - 1) res = f[i] + g[i] - 1;
    printf(&quot;%d\n&quot;, n - res);
    return 0;
}
</code></pre>
<p><br>
<br></p>
<h1 id="导弹拦截"><a href="#导弹拦截" class="headerlink" title="导弹拦截"></a><a href="https://www.luogu.org/problem/show?pid=1020" target="_blank" rel="external">导弹拦截</a></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title=" 题目描述 "></a><strong> 题目描述 </strong></h2><blockquote>
<p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p>
<p>输入导弹依次飞来的高度（雷达给出的高度数据是不大于$50000$的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
</blockquote>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title=" 输入格式 "></a><strong> 输入格式 </strong></h2><blockquote>
<p>一行，若干个整数（个数少于$100000$）。</p>
</blockquote>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title=" 输出格式 "></a><strong> 输出格式 </strong></h2><blockquote>
<p>两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
</blockquote>
<h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title=" 输入样例 "></a><strong> 输入样例 </strong></h2><blockquote>
<p>389 207 155 300 299 170 158 65</p>
</blockquote>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title=" 输出样例 "></a><strong> 输出样例 </strong></h2><blockquote>
<p>6<br>2</p>
</blockquote>
<h2 id="说明-1"><a href="#说明-1" class="headerlink" title=" 说明 "></a><strong> 说明 </strong></h2><blockquote>
<p>第一问直接做最长不下降子序列。<br>对于第二问，有以下贪心：对于当前的导弹，若目前所有的导弹拦截系统的高度都小于其高度，那么要新开一个导弹拦截系统，否则找到一个高度不小于它且高度最小的导弹拦截系统来拦截它。这样直接做是$O(n^2)$的，但是注意到当前所以导弹拦截系统的高度都是不下降的，每次找到一个第一个不小于它的导弹拦截系统来拦截它，这与我们的第二种DP是一样的，所以其实它就是原序列的最长上升子序列的长度。<br>时间复杂度为$O(nlog_{2}n)$。</p>
</blockquote>
<h2 id="标程"><a href="#标程" class="headerlink" title=" 标程 "></a><strong> 标程 </strong></h2><pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n;
int a[N], c[N];

int main() {
    for (n = 0; scanf(&quot;%d&quot;, &amp;a[n + 1]) == 1; ++n);
    int len = 0;
    for (int i = n; i; --i) {
        int j = upper_bound(c + 1, c + len + 1, a[i]) - c;
        c[j] = a[i];
        if (len &lt; j) len = j;
    }
    printf(&quot;%d\n&quot;, len);
    len = 0;
    for (int i = 1; i &lt;= n; ++i) {
        int j = lower_bound(c + 1, c + len + 1, a[i]) - c;
        c[j] = a[i];
        if (len &lt; j) len = j;
    }
    printf(&quot;%d\n&quot;, len);
    return 0;
}
</code></pre>
<p><br>
<br></p>
<h1 id="Beautiful-People"><a href="#Beautiful-People" class="headerlink" title="Beautiful People"></a><a href="http://codeforces.com/gym/100199/problem/G" target="_blank" rel="external">Beautiful People</a></h1><p><center> Input file: people.in</center></p>
<p><center> Output file: people.out</center></p>
<p><center> Time limit: 1 second</center></p>
<h2 id="Description"><a href="#Description" class="headerlink" title=" Description "></a><strong> Description </strong></h2><blockquote>
<p>The most prestigious sports club in one city has exactly N members. Each of its members is strong and beautiful. More precisely, i-th member of this club (members being numbered by the time they entered the club) has strength $S_i$ and beauty $B_i$. Since this is a very prestigious club, its members are very rich and therefore extraordinary people, so they often extremely hate each other. Strictly speaking, i-th member of the club Mr X hates j-th member of the club Mr Y if $S_i \le S_j$ and $B_i \ge B_j$ or if $S_i \ge Sj$ and $B_i \le B_j$ (if both properties of Mr X are greater then corresponding properties of Mr Y, he doesn’t even notice him, on the other hand, if both of his properties are less, he respects Mr Y very much). </p>
<p>To celebrate a new 2003 year, the administration of the club is planning to organize a party. However they are afraid that if two people who hate each other would simultaneouly attend the party, after a drink or two they would start a fight. So no two people who hate each other should be invited. On the other hand, to keep the club prestige at the apropriate level, administration wants to invite as many people as possible.</p>
<p>Being the only one among administration who is not afraid of touching a computer, you are to write a program which would find out whom to invite to the party.</p>
</blockquote>
<h2 id="Input"><a href="#Input" class="headerlink" title=" Input "></a><strong> Input </strong></h2><blockquote>
<p>The first line of the input file contains integer N — the number of members of the club. ($2 \le N \le 100000$). Next N lines contain two numbers each — Si and Bi respectively ($1 \le S_i, B_i \le 10^9$).</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title=" Output "></a><strong> Output </strong></h2><blockquote>
<p>On the first line of the output file print the maximum number of the people that can be invited to the party. On the second line output N integers — numbers of members to be invited in arbitrary order. If several solutions exist, output any one.</p>
</blockquote>
<h2 id="Example"><a href="#Example" class="headerlink" title=" Example "></a><strong> Example </strong></h2><h3 id="people-in"><a href="#people-in" class="headerlink" title=" people.in  "></a><strong> people.in  </strong></h3><blockquote>
<p>4<br>1 1<br>1 2<br>2 1<br>2 2</p>
</blockquote>
<h3 id="people-out"><a href="#people-out" class="headerlink" title=" people.out "></a><strong> people.out </strong></h3><blockquote>
<p>2<br>1 4</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title=" Solution "></a><strong> Solution </strong></h2><blockquote>
<p>一个俱乐部有$n$个成员，每个成员有力量值$S_i$和美丽值$B_i$，成员$i$与成员$j$互相讨厌当且仅当$(S_i \le S_j \  \&amp; \&amp; \  B_i \ge B_j) \  | | \  (S_i \ge Sj \  \&amp; \&amp; \  B_i \le B_j)$。现在该俱乐部要组织一个聚会，问你最多邀请多少人，满足他们都不互相讨厌，输出最多人数及方案（任意一种）。</p>
<p>分析发现，对于合法安排方案的两个成员$i,j$，$S_i \neq S_j \  \&amp; \&amp; \  B_i \neq B_j \  \&amp; \&amp; \  sgn(S_i - S_j) = sgn(B_i - B_j)$。<br>那么这就是一个二维的最长上升子序列问题，先对第一维排序，再对第二位做最长上升子序列。因为最后的子序列的第一维不能相同，所以我们排序时先对第一维从小到大排序，第一维相同的按第二维从大到小排序，这样保证了第一维相同的第二维小的不会更新第二维大的，保证了算法的正确性。<br>这题还要输路径，与就是普通的输路径方法。<br>时间复杂度为$O(nlog_{2}n)$。</p>
</blockquote>
<h2 id="Standrad"><a href="#Standrad" class="headerlink" title=" Standrad "></a><strong> Standrad </strong></h2><pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

inline void FO() {
    freopen(&quot;people.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;people.out&quot;, &quot;w&quot;, stdout);
    return;
}

const int N = 100010, INF = 0x7fffffff;

int n, len;
int pre[N], from[N], c[N];
struct Node {
    int s, b, idx;
    bool operator &lt; (const Node &amp;a) const {
        return (s != a.s) ? (s &lt; a.s) : (b &gt; a.b);
    }
} a[N];

int main() {
    FO();
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i) {
        scanf(&quot;%d%d&quot;, &amp;a[i].s, &amp;a[i].b);
        a[i].idx = i;
    }
    sort(a + 1, a + n + 1);
    for (int i = 1; i &lt;= n; ++i) {
        int k = lower_bound(c + 1, c + len + 1, a[i].b) - c;
        c[k] = a[i].b;
        from[k] = i;
        pre[i] = from[k - 1];
        if (len &lt; k) len = k;
    }
    printf(&quot;%d\n&quot;, len);
    for (int i = from[len]; i; i = pre[i])
        printf(&quot;%d &quot;, a[i].idx);
    putchar(&#39;\n&#39;);
    return 0;
}
</code></pre>
<p><br>
<br></p>
<h1 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a><a href="http://codeforces.com/problemset/problem/568/E" target="_blank" rel="external">Longest Increasing Subsequence</a></h1><p><center> time limit per test1.5 seconds</center></p>
<p><center> memory limit per test128 megabytes</center></p>
<p><center> inputstandard input</center></p>
<p><center> outputstandard output</center></p>
<h2 id="Description-1"><a href="#Description-1" class="headerlink" title=" Description "></a><strong> Description </strong></h2><blockquote>
<p>Note that the memory limit in this problem is less than usual.</p>
<p>Let’s consider an array consisting of positive integers, some positions of which contain gaps.</p>
<p>We have a collection of numbers that can be used to fill the gaps. Each number from the given collection can be used at most once.</p>
<p>Your task is to determine such way of filling gaps that the longest increasing subsequence in the formed array has a maximum size.</p>
</blockquote>
<h2 id="Input-1"><a href="#Input-1" class="headerlink" title=" Input "></a><strong> Input </strong></h2><blockquote>
<p>The first line contains a single integer $n$ — the length of the array ($1 \le n \le 10^5$).</p>
<p>The second line contains $n$ space-separated integers — the elements of the sequence. A gap is marked as “-1”. The elements that are not gaps are positive integers not exceeding $10^9$. It is guaranteed that the sequence contains $0 \le k \le 1000$ gaps.</p>
<p>The third line contains a single positive integer $m$ — the number of elements to fill the gaps ($k \le m \le 10^5$).</p>
<p>The fourth line contains $m$ positive integers — the numbers to fill gaps. Each number is a positive integer not exceeding $10^9$. Some numbers may be equal.</p>
</blockquote>
<h2 id="Output-1"><a href="#Output-1" class="headerlink" title=" Output "></a><strong> Output </strong></h2><blockquote>
<p>Print $n$ space-separated numbers in a single line — the resulting sequence. If there are multiple possible answers, print any of them.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title=" Examples "></a><strong> Examples </strong></h2><h3 id="input"><a href="#input" class="headerlink" title=" input "></a><strong> input </strong></h3><blockquote>
<p>3<br>1 2 3<br>1<br>10</p>
</blockquote>
<h3 id="output"><a href="#output" class="headerlink" title=" output "></a><strong> output </strong></h3><blockquote>
<p>1 2 3</p>
</blockquote>
<h3 id="input-1"><a href="#input-1" class="headerlink" title=" input "></a><strong> input </strong></h3><blockquote>
<p>3<br>1 -1 3<br>3<br>1 2 3</p>
</blockquote>
<h3 id="output-1"><a href="#output-1" class="headerlink" title=" output "></a><strong> output </strong></h3><blockquote>
<p>1 2 3</p>
</blockquote>
<h3 id="input-2"><a href="#input-2" class="headerlink" title=" input "></a><strong> input </strong></h3><blockquote>
<p>2<br>-1 2<br>2<br>2 4</p>
</blockquote>
<h3 id="output-2"><a href="#output-2" class="headerlink" title=" output "></a><strong> output </strong></h3><blockquote>
<p>2 2</p>
</blockquote>
<h3 id="input-3"><a href="#input-3" class="headerlink" title=" input "></a><strong> input </strong></h3><blockquote>
<p>3<br>-1 -1 -1<br>5<br>1 1 1 1 2</p>
</blockquote>
<h3 id="output-3"><a href="#output-3" class="headerlink" title=" output "></a><strong> output </strong></h3><blockquote>
<p>1 1 2</p>
</blockquote>
<h3 id="input-4"><a href="#input-4" class="headerlink" title=" input "></a><strong> input </strong></h3><blockquote>
<p>4<br>-1 -1 -1 2<br>4<br>1 1 2 2</p>
</blockquote>
<h3 id="output-4"><a href="#output-4" class="headerlink" title=" output "></a><strong> output </strong></h3><blockquote>
<p>1 2 1 2</p>
</blockquote>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title=" Solution "></a><strong> Solution </strong></h2><blockquote>
<p>给你一个长度为$n$的序列，序列中有$k$个位置是空缺的，你现在有$m$个数，你可以把它们填入空缺的位置，每个数只能用一次，最大化最后序列的最长上升子序列的长度，输出最后序列。</p>
<p>因为一个最长上升子序列中不会有重复的数，所以可以假设可填的数可以用多次，就先把可填的数排序。<br>用第二种DP。1. 对于原来就有的位置，直接$lower \underline{} bound$求。2. 对于空缺的位置，可以一次$O(n)$求出所有可填的数的$lower \underline{} bound$。<br>安排最长上升子序列的空缺位置后，随意安排剩下的空缺的位置。<br>时间复杂度为$O(nlog_{2}n + mlog_{2}m + k \times m)$。</p>
</blockquote>
<h2 id="Standrad-1"><a href="#Standrad-1" class="headerlink" title=" Standrad "></a><strong> Standrad </strong></h2><pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010, INF = 0x7fffffff;

int n, m, len;
int a[N], b[N], c[N], pre[N], from[N], temp[N];
bool v[N];

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, &amp;a[i]);
    scanf(&quot;%d&quot;, &amp;m);
    for (int i = 1; i &lt;= m; ++i)
        scanf(&quot;%d&quot;, &amp;b[i]);
    sort(b + 1, b + m + 1);
    for (int i = 1; i &lt;= n; ++i)
        if (~a[i]) {
            int j = lower_bound(c + 1, c + len + 1, a[i]) - c;
            pre[i] = from[j - 1];
            from[j] = i;
            c[j] = a[i];
            if (len &lt; j) len = j;
        } else {
            int j = 1;
            for (int k = 1; k &lt;= m; ++k) {
                while (j &lt;= len &amp;&amp; c[j] &lt; b[k]) ++j;
                temp[k] = j;
            }
            if (len &lt; j) len = j;
            for (int k = m; k; --k) {
                c[temp[k]] = b[k];
                from[temp[k]] = from[temp[k] - 1];
            }
        }
    int cnt = 0;
    for (int i = from[len]; i; i = pre[i])
        temp[++cnt] = i;
    temp[0] = n + 1;
    temp[cnt + 1] = 0;
    a[n + 1] = INF;
    for (int i = cnt + 1; i; --i) {
        int last = a[temp[i]];
        for (int j = temp[i] + 1; j &lt; temp[i - 1]; ++j)
            if (!~a[j]) {
                int k = upper_bound(b + 1, b + m + 1, last) - b;
                if (k &gt; m || b[k] &gt;= a[temp[i - 1]]) break;
                last = a[j] = b[k];
                v[k] = 1;
            }
    }
    for (int i = 1, j = 1; i &lt;= n; ++i)
        if (!~a[i]) {
            while (j &lt; m &amp;&amp; v[j]) ++j;
            a[i] = b[j];
            v[j] = 1;
        }
    //cerr &lt;&lt; len &lt;&lt; endl;
    for (int i = 1; i &lt;= n; ++i)
        printf(&quot;%d &quot;, a[i]);
    putchar(&#39;\n&#39;);
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2017初赛准备]]></title>
      <url>/2017/10/14/NOIP2017%E5%88%9D%E8%B5%9B%E5%87%86%E5%A4%87/</url>
      <content type="html"><![CDATA[<h1 id="NOIP2007提高组初赛"><a href="#NOIP2007提高组初赛" class="headerlink" title="NOIP2007提高组初赛"></a>NOIP2007提高组初赛</h1><h2 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h2><h3 id="一、单项选择题"><a href="#一、单项选择题" class="headerlink" title="一、单项选择题"></a>一、单项选择题</h3><p>2．在关系数据库中，存放在数据库中的数据的逻辑结构以（ ）为主。<br>A. 二叉树  B. 多叉树  C. 哈希表  D. B+树  E. 二维表</p>
<p>5．在C++语言中，表达式23|2^5的值是（ ）<br>A. 23  B. 1  C. 18  D. 32  E. 24</p>
<h3 id="二、不定项选择题"><a href="#二、不定项选择题" class="headerlink" title="二、不定项选择题"></a>二、不定项选择题</h3><p>16.在下列各软件中，属于NOIP 竞赛（复赛）推荐使用的语言环境有（ ）。<br>A. gcc B. g++  C. Turbo C  D. free pascal</p>
<h3 id="三、问题求解"><a href="#三、问题求解" class="headerlink" title="三、问题求解"></a>三、问题求解</h3><p>2．N个人在操场里围成一圈，将这N个人按顺时针方向从1到N编号，然后，从第一个人起，每隔一个人让下一个人离开操场，显然，第一轮过后，具有偶数编号的人都离开了操场。依次做下去，直到操场只剩下一个人，记这个人的编号为J(N)，例如，J(5)=3，J(10)=5，等等。则J(400)=<strong><strong><strong>__</strong></strong></strong>。<br>（提示：对 N=2^m+r进行分析，其中 0≤r&lt;2^m）。</p>
<h3 id="四、阅读程序写结果"><a href="#四、阅读程序写结果" class="headerlink" title="四、阅读程序写结果"></a>四、阅读程序写结果</h3><p>2.</p>
<pre><code class="lang-cpp">#include &lt;iostream&gt;

using namespace std;

void fun(int *a, int *b) {
    int *k;
    k = a;
    a = b;
    b = k;
    return;
}

int main() {
    int a = 3, b = 6, *x = &amp;a, *y = &amp;b;
    fun(x, y);
    cout &lt;&lt; &quot;No.1:&quot; &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; &quot; &quot;;
    fun(&amp;a, &amp;b);
    cout &lt;&lt; &quot;No.2:&quot; &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="五、完善程序"><a href="#五、完善程序" class="headerlink" title="五、完善程序"></a>五、完善程序</h3><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="一、单项选择题-1"><a href="#一、单项选择题-1" class="headerlink" title="一、单项选择题"></a>一、单项选择题</h3><ol>
<li>$E$</li>
</ol>
<p>数据库有层次型数据库，关系型数据库，网状数据库。层次是树，关系是二维表，网状是链接指针。</p>
<ol>
<li>$A$</li>
</ol>
<p>|优先级比^低，所以23|2^5=23|(2^5)。</p>
<h3 id="二、不定项选择题-1"><a href="#二、不定项选择题-1" class="headerlink" title="二、不定项选择题"></a>二、不定项选择题</h3><ol>
<li>$ABD$</li>
</ol>
<h3 id="三、问题求解-1"><a href="#三、问题求解-1" class="headerlink" title="三、问题求解"></a>三、问题求解</h3><ol>
<li>$289$</li>
</ol>
<h3 id="四、阅读程序写结果-1"><a href="#四、阅读程序写结果-1" class="headerlink" title="四、阅读程序写结果"></a>四、阅读程序写结果</h3><ol>
<li>$No.1:3,6 No.2:3,6$</li>
</ol>
<h3 id="五、完善程序-1"><a href="#五、完善程序-1" class="headerlink" title="五、完善程序"></a>五、完善程序</h3><h1 id="NOIP2008提高组初赛"><a href="#NOIP2008提高组初赛" class="headerlink" title="NOIP2008提高组初赛"></a>NOIP2008提高组初赛</h1><h2 id="错题-1"><a href="#错题-1" class="headerlink" title="错题"></a>错题</h2><h3 id="一、单项选择题-2"><a href="#一、单项选择题-2" class="headerlink" title="一、单项选择题"></a>一、单项选择题</h3><ol>
<li><p>在以下各项中，（  ）不是操作系统软件。<br>A. Solaris  B. Linux  C. Sybase  D. Windows Vista  E. Symbian</p>
</li>
<li><p>TCP/IP是一组构成互联网基础的网络协议，字面上包括两组协议：传输控制协议（TCP）和网际协议（IP）。TCP/IP 协议把Internet网络系统描述成具有四个层次功能的网络模型,其中提供源节点和目的节点之间的信息传输服务，包括寻址和路由器选择等功能的是（）。<br>A. 链路层  B. 网络层  C. 传输层  D. 应用层  E. 会话层</p>
</li>
</ol>
<h3 id="二、不定项选择题-2"><a href="#二、不定项选择题-2" class="headerlink" title="二、不定项选择题"></a>二、不定项选择题</h3><p>14．Web2.0是近年来互联网的热门概念之一，其核心思想是互动与分享。下列网站中，（   ）是典型的Web2.0应用。<br>A. Sina   B. Flickr  C. Yahoo  D. Google</p>
<ol>
<li><p>面向对象程序设计（Object-Oriented Programming）是一种程序设计的方法论，它将对象作为程序的基本单元，将数据和程序封装在对象中，以提高软件的重用性、灵活性和扩展性。下面关于面向对象程序设计的说法中，正确的是（   ）。<br>A. 面向对象程序设计通常采用自顶向下设计方法进行设计。<br>B. 面向对象程序设计方法具有继承性（inheritance）、封装性（encapsulation）、多态性（polymorphism）等几大特点。<br>C. 支持面向对象特性的语言称为面向对象的编程语言，目前较为流行的有C++、JAVA、C#等。<br>D. 面向对象的程序设计的雏形来自于Simula语言，后来在SmallTalk语言的完善和标准化的过程中得到更多的扩展和对以前思想的重新注解。至今，SmallTalk语言仍然被视为面向对象语言的基础。</p>
</li>
<li><p>NOIP竞赛推荐使用的语言环境有（   ）。<br>A. Dev-C++  B. Visual C++  C. free pascal  D. Lazarus</p>
</li>
</ol>
<h3 id="三、问题求解-2"><a href="#三、问题求解-2" class="headerlink" title="三、问题求解"></a>三、问题求解</h3><h3 id="四、阅读程序写结果-2"><a href="#四、阅读程序写结果-2" class="headerlink" title="四、阅读程序写结果"></a>四、阅读程序写结果</h3><h2 id="五、完善程序-2"><a href="#五、完善程序-2" class="headerlink" title="五、完善程序"></a>五、完善程序</h2><h2 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h2><h3 id="一、单项选择题-3"><a href="#一、单项选择题-3" class="headerlink" title="一、单项选择题"></a>一、单项选择题</h3><ol>
<li><p>$C$<br>Solaris：Sun Microsystems研发的计算机操作系统。<br>Linux：是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。<br>Sybase：美国Sybase公司研制的一种关系型数据库系统，是一种典型的UNIX或WindowsNT平台上客户机/服务器环境下的大型数据库系统。<br>Windows Vista：Microsoft Windows操作系统，Windows XP的下一个版本。<br>Symbian：Symbian系统是塞班公司为手机而设计的操作系统。</p>
</li>
<li><p>$B$<br>TCP/IP协议：Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。</p>
</li>
</ol>
<h3 id="二、不定项选择题-3"><a href="#二、不定项选择题-3" class="headerlink" title="二、不定项选择题"></a>二、不定项选择题</h3><ol>
<li>$B$</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Web 1.0</th>
<th style="text-align:center">Web 2.0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">DoubleClick</td>
<td style="text-align:center">Google AdSense</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Ofoto</td>
<td style="text-align:center">Flickr</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">Akamai</td>
<td style="text-align:center">Wikipedia</td>
</tr>
<tr>
<td style="text-align:center">etc.</td>
<td style="text-align:center">etc.</td>
<td style="text-align:center">etc.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="三、问题求解-3"><a href="#三、问题求解-3" class="headerlink" title="三、问题求解"></a>三、问题求解</h3><h3 id="四、阅读程序写结果-3"><a href="#四、阅读程序写结果-3" class="headerlink" title="四、阅读程序写结果"></a>四、阅读程序写结果</h3><h3 id="五、完善程序-3"><a href="#五、完善程序-3" class="headerlink" title="五、完善程序"></a>五、完善程序</h3><h1 id="NOIP2009提高组初赛"><a href="#NOIP2009提高组初赛" class="headerlink" title="NOIP2009提高组初赛"></a>NOIP2009提高组初赛</h1><h2 id="错题-2"><a href="#错题-2" class="headerlink" title="错题"></a>错题</h2><h3 id="一、单项选择题-4"><a href="#一、单项选择题-4" class="headerlink" title="一、单项选择题"></a>一、单项选择题</h3><h3 id="二、不定项选择题-4"><a href="#二、不定项选择题-4" class="headerlink" title="二、不定项选择题"></a>二、不定项选择题</h3><h3 id="三、问题求解-4"><a href="#三、问题求解-4" class="headerlink" title="三、问题求解"></a>三、问题求解</h3><h3 id="四、阅读程序写结果-4"><a href="#四、阅读程序写结果-4" class="headerlink" title="四、阅读程序写结果"></a>四、阅读程序写结果</h3><h3 id="五、完善程序-4"><a href="#五、完善程序-4" class="headerlink" title="五、完善程序"></a>五、完善程序</h3><h2 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h2><h3 id="一、单项选择题-5"><a href="#一、单项选择题-5" class="headerlink" title="一、单项选择题"></a>一、单项选择题</h3><h3 id="二、不定项选择题-5"><a href="#二、不定项选择题-5" class="headerlink" title="二、不定项选择题"></a>二、不定项选择题</h3><h3 id="三、问题求解-5"><a href="#三、问题求解-5" class="headerlink" title="三、问题求解"></a>三、问题求解</h3><h3 id="四、阅读程序写结果-5"><a href="#四、阅读程序写结果-5" class="headerlink" title="四、阅读程序写结果"></a>四、阅读程序写结果</h3><h3 id="五、完善程序-5"><a href="#五、完善程序-5" class="headerlink" title="五、完善程序"></a>五、完善程序</h3><p>Templete</p>
<h1 id="NOIP20提高组初赛"><a href="#NOIP20提高组初赛" class="headerlink" title="NOIP20提高组初赛"></a>NOIP20提高组初赛</h1><h2 id="错题-3"><a href="#错题-3" class="headerlink" title="错题"></a>错题</h2><h3 id="一、单项选择题-6"><a href="#一、单项选择题-6" class="headerlink" title="一、单项选择题"></a>一、单项选择题</h3><h3 id="二、不定项选择题-6"><a href="#二、不定项选择题-6" class="headerlink" title="二、不定项选择题"></a>二、不定项选择题</h3><h3 id="三、问题求解-6"><a href="#三、问题求解-6" class="headerlink" title="三、问题求解"></a>三、问题求解</h3><h3 id="四、阅读程序写结果-6"><a href="#四、阅读程序写结果-6" class="headerlink" title="四、阅读程序写结果"></a>四、阅读程序写结果</h3><h3 id="五、完善程序-6"><a href="#五、完善程序-6" class="headerlink" title="五、完善程序"></a>五、完善程序</h3><h2 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h2><h3 id="一、单项选择题-7"><a href="#一、单项选择题-7" class="headerlink" title="一、单项选择题"></a>一、单项选择题</h3><h3 id="二、不定项选择题-7"><a href="#二、不定项选择题-7" class="headerlink" title="二、不定项选择题"></a>二、不定项选择题</h3><h3 id="三、问题求解-7"><a href="#三、问题求解-7" class="headerlink" title="三、问题求解"></a>三、问题求解</h3><h3 id="四、阅读程序写结果-7"><a href="#四、阅读程序写结果-7" class="headerlink" title="四、阅读程序写结果"></a>四、阅读程序写结果</h3><h3 id="五、完善程序-7"><a href="#五、完善程序-7" class="headerlink" title="五、完善程序"></a>五、完善程序</h3>]]></content>
      
        <categories>
            
            <category> NOIP初赛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 选择题 </tag>
            
            <tag> 问题求解 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BZOJ1968]]></title>
      <url>/2017/09/25/BZOJ1968/</url>
      <content type="html"><![CDATA[<h1 id="AHOI2005-COMMON-约数研究"><a href="#AHOI2005-COMMON-约数研究" class="headerlink" title="[AHOI2005]COMMON 约数研究"></a><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1968" target="_blank" rel="external">[AHOI2005]COMMON 约数研究</a></h1><p><center> Time Limit: 1 Sec  Memory Limit: 64 MB</center></p>
<h2 id="Description"><a href="#Description" class="headerlink" title=" Description "></a><strong> Description </strong></h2><blockquote>
<p>科学家们在 Samuel 星球上的探险得到了丰富的能源储备，这使得空间站中大型计算机 “Samuel II” 的长时间运算成为了可能。由于在去年一年的辛苦工作取得了不错的成绩，小联被允许用 “Samuel II” 进行数学研究。</p>
<p>小联最近在研究和约数有关的问题，他统计每个正数$N$的约数的个数，并以$f(N)$来表示。例如$12$的约数有$1$、$2$、$3$、$4$、$6$、$12$。因此$f(12)=6$。下表给出了一些$f(N)$的取值：</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>$n$</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>$f(n)$</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>2</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>现在小联希望用 “Samuel II” 来统计$f(1)$到$f(n)$的累加和$M$。</p>
</blockquote>
<h2 id="Input"><a href="#Input" class="headerlink" title=" Input "></a><strong> Input </strong></h2><blockquote>
<p>只有一行一个整数$N$（$0 &lt; N &lt; 1000000$）。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title=" Output "></a><strong> Output </strong></h2><blockquote>
<p>只有一行输出，为整数$M$，即$f(1)$到$f(N)$的累加和。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title=" Sample Input "></a><strong> Sample Input </strong></h2><blockquote>
<p>3</p>
</blockquote>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title=" Sample Output "></a><strong> Sample Output </strong></h2><blockquote>
<p>5</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title=" Solution "></a><strong> Solution </strong></h2><blockquote>
<p>对于$i$，它会成为$i$,$i \times 2$,…,$i \times (n / i)$的因子，它对答案的贡献为$n / i$。</p>
</blockquote>
<h2 id="Standard"><a href="#Standard" class="headerlink" title=" Standard "></a><strong> Standard </strong></h2><pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

int n, sum = 0;

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i)
        sum += n / i;
    printf(&quot;%d\n&quot;, sum);
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> BZOJ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BZOJ2463]]></title>
      <url>/2017/09/23/BZOJ2463/</url>
      <content type="html"><![CDATA[<h1 id="2463-中山市选2009-谁能赢呢？"><a href="#2463-中山市选2009-谁能赢呢？" class="headerlink" title="2463: [中山市选2009]谁能赢呢？"></a><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2463" target="_blank" rel="external">2463: [中山市选2009]谁能赢呢？</a></h1><p><center> Time Limit: 10 Sec  Memory Limit: 128 MB</center></p>
<h2 id="Description"><a href="#Description" class="headerlink" title=" Description "></a><strong> Description </strong></h2><blockquote>
<p>小明和小红经常玩一个博弈游戏。给定一个$n \times n$的棋盘，一个石头被放在棋盘的左上角。他们轮流移动石头。每一回合，选手只能把石头向上，下，左，右四个方向移动一格，并且要求移动到的格子之前不能被访问过。谁不能移动石头了就算输。假如小明先移动石头，而且两个选手都以最优策略走步，问最后谁能赢？</p>
</blockquote>
<h2 id="Input"><a href="#Input" class="headerlink" title=" Input "></a><strong> Input </strong></h2><blockquote>
<p>输入文件有多组数据。</p>
<p>输入第一行包含一个整数$n$，表示棋盘的规模。</p>
<p>当输入$n$为$0$时，表示输入结束。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title=" Output "></a><strong> Output </strong></h2><blockquote>
<p>对于每组数据，如果小明最后能赢，则输出 “Alice”, 否则输出 “Bob”, 每一组答案独占一行。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title=" Sample Input "></a><strong> Sample Input </strong></h2><blockquote>
<p>2<br>0</p>
</blockquote>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title=" Sample Output "></a><strong> Sample Output </strong></h2><blockquote>
<p>Alice</p>
</blockquote>
<h2 id="HINT"><a href="#HINT" class="headerlink" title=" HINT "></a><strong> HINT </strong></h2><blockquote>
<p>对于所有的数据，保证$1 &lt;= n &lt;= 10000$。</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title=" Solution "></a><strong> Solution </strong></h2><blockquote>
<p>当$n$为偶数，棋盘一定能被$1 \times 2$的骨牌覆盖，所以我们先对棋盘进行覆盖，Alice 移动的每一步为原位置所在骨牌的另一块，Bob 则必须选择新的一块骨牌，所以最后一定是 Bob 找不到一块新的骨牌。Alice 必胜。</p>
<p>当$n$为奇数，棋盘上除去起点的点一定能被$1 \times 2$的骨牌覆盖，所以我们先对棋盘进行覆盖，Alice 每次进入一块新的骨牌，Bob 移动的每一步为原位置所在骨牌的另一块，所以最后一定是 Alice 找不到一块新的骨牌。Bob 必胜。</p>
</blockquote>
<h2 id="Standard"><a href="#Standard" class="headerlink" title=" Standard "></a><strong> Standard </strong></h2><pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

int n;

int main() {
    while (scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) {
        if (n &amp; 1) puts(&quot;Bob&quot;);
        else puts(&quot;Alice&quot;);
    }
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> BZOJ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博弈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World!]]></title>
      <url>/2017/09/23/Hello%20World!/</url>
      <content type="html"><![CDATA[<p>这是一篇有关 <strong><em> OI </em></strong> 的博客。</p>
<pre><code class="lang-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

int main() {
    puts(&quot;Hello World!&quot;);
    return 0;
}
</code></pre>
]]></content>
      
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[About]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>QQ：1749046292 &amp;&amp; 2445613176</p>
<p><a href="https://www.luogu.org/space/show?uid=20593" target="_blank" rel="external">Luogu</a></p>
<p><a href="http://www.lydsy.com/JudgeOnline/userinfo.php?user=qxj" target="_blank" rel="external">Lydsy</a></p>
<p><a href="http://codeforces.com/profile/qxj123" target="_blank" rel="external">CodeForces</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gallery]]></title>
      <url>/gallery/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Game]]></title>
      <url>/game/index.html</url>
      <content type="html"><![CDATA[<p><a href="/game/2048/index.html" target="_blank" style="text-decoration:none"> <font size="18px" color="#776e65"> 2048 </font> </a></p>
<p><a href="/game/tetris/index.html" target="_blank" style="text-decoration:none"> <font size="18px" color="#776e65"> tetris </font> </a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Links]]></title>
      <url>/links/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Timeline]]></title>
      <url>/timeline/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
